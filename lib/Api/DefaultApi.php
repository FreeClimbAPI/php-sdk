<?php

/**
 * DefaultApi
 * PHP version 7.4
 *
 * @category Class
 * @package  FreeClimb\Api
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * FreeClimb API
 *
 * FreeClimb is a cloud-based application programming interface (API) that puts the power of the Vail platform in your hands. FreeClimb simplifies the process of creating applications that can use a full range of telephony features without requiring specialized or on-site telephony equipment. Using the FreeClimb REST API to write applications is easy! You have the option to use the language of your choice or hit the API directly. Your application can execute a command by issuing a RESTful request to the FreeClimb API. The base URL to send HTTP requests to the FreeClimb REST API is: /apiserver. FreeClimb authenticates and processes your request.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@freeclimb.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace FreeClimb\Api\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use FreeClimb\Api\ApiException;
use FreeClimb\Api\Configuration;
use FreeClimb\Api\HeaderSelector;
use FreeClimb\Api\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  FreeClimb\Api
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'buyAPhoneNumber' => [
            'application/json',
        ],
        'createAConference' => [
            'application/json',
        ],
        'createAQueue' => [
            'application/json',
        ],
        'createAnApplication' => [
            'application/json',
        ],
        'createKnowledgeBaseCompletion' => [
            'application/json',
        ],
        'deleteARecording' => [
            'application/json',
        ],
        'deleteAnApplication' => [
            'application/json',
        ],
        'deleteAnIncomingNumber' => [
            'application/json',
        ],
        'dequeueAMember' => [
            'application/json',
        ],
        'dequeueHeadMember' => [
            'application/json',
        ],
        'downloadARecordingFile' => [
            'application/json',
        ],
        'filterLogs' => [
            'application/json',
        ],
        'getACall' => [
            'application/json',
        ],
        'getAConference' => [
            'application/json',
        ],
        'getAMember' => [
            'application/json',
        ],
        'getAParticipant' => [
            'application/json',
        ],
        'getAQueue' => [
            'application/json',
        ],
        'getARecording' => [
            'application/json',
        ],
        'getAnAccount' => [
            'application/json',
        ],
        'getAnApplication' => [
            'application/json',
        ],
        'getAnIncomingNumber' => [
            'application/json',
        ],
        'getAnSmsMessage' => [
            'application/json',
        ],
        'getHeadMember' => [
            'application/json',
        ],
        'getTenDLCSmsBrand' => [
            'application/json',
        ],
        'getTenDLCSmsBrands' => [
            'application/json',
        ],
        'getTenDLCSmsCampaign' => [
            'application/json',
        ],
        'getTenDLCSmsCampaigns' => [
            'application/json',
        ],
        'getTenDLCSmsPartnerCampaign' => [
            'application/json',
        ],
        'getTenDLCSmsPartnerCampaigns' => [
            'application/json',
        ],
        'getTollFreeSmsCampaign' => [
            'application/json',
        ],
        'getTollFreeSmsCampaigns' => [
            'application/json',
        ],
        'listActiveQueues' => [
            'application/json',
        ],
        'listAllAccountLogs' => [
            'application/json',
        ],
        'listApplications' => [
            'application/json',
        ],
        'listAvailableNumbers' => [
            'application/json',
        ],
        'listCallLogs' => [
            'application/json',
        ],
        'listCallRecordings' => [
            'application/json',
        ],
        'listCalls' => [
            'application/json',
        ],
        'listConferenceRecordings' => [
            'application/json',
        ],
        'listConferences' => [
            'application/json',
        ],
        'listIncomingNumbers' => [
            'application/json',
        ],
        'listMembers' => [
            'application/json',
        ],
        'listParticipants' => [
            'application/json',
        ],
        'listRecordings' => [
            'application/json',
        ],
        'listSmsMessages' => [
            'application/json',
        ],
        'makeACall' => [
            'application/json',
        ],
        'makeAWebrtcJwt' => [
            'application/json',
        ],
        'removeAParticipant' => [
            'application/json',
        ],
        'sendAnSmsMessage' => [
            'application/json',
        ],
        'streamARecordingFile' => [
            'application/json',
        ],
        'updateAConference' => [
            'application/json',
        ],
        'updateALiveCall' => [
            'application/json',
        ],
        'updateAParticipant' => [
            'application/json',
        ],
        'updateAQueue' => [
            'application/json',
        ],
        'updateAnAccount' => [
            'application/json',
        ],
        'updateAnApplication' => [
            'application/json',
        ],
        'updateAnIncomingNumber' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation buyAPhoneNumber
     *
     * Buy a Phone Number
     *

     * @param  \FreeClimb\Api\Model\BuyIncomingNumberRequest $buy_incoming_number_request Incoming Number transaction details (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buyAPhoneNumber'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\IncomingNumberResult
     */
    public function buyAPhoneNumber($buy_incoming_number_request, string $contentType = self::contentTypes['buyAPhoneNumber'][0])
    {
        list($response) = $this->buyAPhoneNumberWithHttpInfo($buy_incoming_number_request, $contentType);
        return $response;
    }     
    /**
     * Operation buyAPhoneNumberWithHttpInfo
     *
     * Buy a Phone Number
     *

     * @param  \FreeClimb\Api\Model\BuyIncomingNumberRequest $buy_incoming_number_request Incoming Number transaction details (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buyAPhoneNumber'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\IncomingNumberResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function buyAPhoneNumberWithHttpInfo($buy_incoming_number_request, string $contentType = self::contentTypes['buyAPhoneNumber'][0])
    {
        $request = $this->buyAPhoneNumberRequest($buy_incoming_number_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\IncomingNumberResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\IncomingNumberResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\IncomingNumberResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\IncomingNumberResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\IncomingNumberResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buyAPhoneNumberAsync
     *
     * Buy a Phone Number
     *

     * @param  \FreeClimb\Api\Model\BuyIncomingNumberRequest $buy_incoming_number_request Incoming Number transaction details (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buyAPhoneNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buyAPhoneNumberAsync($buy_incoming_number_request, string $contentType = self::contentTypes['buyAPhoneNumber'][0])
    {
        return $this->buyAPhoneNumberAsyncWithHttpInfo($buy_incoming_number_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buyAPhoneNumberAsyncWithHttpInfo
     *
     * Buy a Phone Number
     *

     * @param  \FreeClimb\Api\Model\BuyIncomingNumberRequest $buy_incoming_number_request Incoming Number transaction details (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buyAPhoneNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buyAPhoneNumberAsyncWithHttpInfo($buy_incoming_number_request, string $contentType = self::contentTypes['buyAPhoneNumber'][0])
    {
        $returnType = '\FreeClimb\Api\Model\IncomingNumberResult';
        $request = $this->buyAPhoneNumberRequest($buy_incoming_number_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buyAPhoneNumber'
     *

     * @param  \FreeClimb\Api\Model\BuyIncomingNumberRequest $buy_incoming_number_request Incoming Number transaction details (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buyAPhoneNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function buyAPhoneNumberRequest($buy_incoming_number_request, string $contentType = self::contentTypes['buyAPhoneNumber'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'buy_incoming_number_request' is set
        if ($buy_incoming_number_request === null || (is_array($buy_incoming_number_request) && count($buy_incoming_number_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $buy_incoming_number_request when calling buyAPhoneNumber'
            );
        }



        $resourcePath = '/Accounts/{accountId}/IncomingPhoneNumbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($buy_incoming_number_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($buy_incoming_number_request));
            } else {
                $httpBody = $buy_incoming_number_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAConference
     *
     * Create a Conference
     *

     * @param  \FreeClimb\Api\Model\CreateConferenceRequest $create_conference_request Conference to create (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAConference'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\ConferenceResult
     */
    public function createAConference($create_conference_request = null, string $contentType = self::contentTypes['createAConference'][0])
    {
        list($response) = $this->createAConferenceWithHttpInfo($create_conference_request, $contentType);
        return $response;
    }     
    /**
     * Operation createAConferenceWithHttpInfo
     *
     * Create a Conference
     *

     * @param  \FreeClimb\Api\Model\CreateConferenceRequest $create_conference_request Conference to create (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAConference'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\ConferenceResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAConferenceWithHttpInfo($create_conference_request = null, string $contentType = self::contentTypes['createAConference'][0])
    {
        $request = $this->createAConferenceRequest($create_conference_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\ConferenceResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\ConferenceResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\ConferenceResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\ConferenceResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\ConferenceResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAConferenceAsync
     *
     * Create a Conference
     *

     * @param  \FreeClimb\Api\Model\CreateConferenceRequest $create_conference_request Conference to create (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAConference'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAConferenceAsync($create_conference_request = null, string $contentType = self::contentTypes['createAConference'][0])
    {
        return $this->createAConferenceAsyncWithHttpInfo($create_conference_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAConferenceAsyncWithHttpInfo
     *
     * Create a Conference
     *

     * @param  \FreeClimb\Api\Model\CreateConferenceRequest $create_conference_request Conference to create (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAConference'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAConferenceAsyncWithHttpInfo($create_conference_request = null, string $contentType = self::contentTypes['createAConference'][0])
    {
        $returnType = '\FreeClimb\Api\Model\ConferenceResult';
        $request = $this->createAConferenceRequest($create_conference_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAConference'
     *

     * @param  \FreeClimb\Api\Model\CreateConferenceRequest $create_conference_request Conference to create (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAConference'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAConferenceRequest($create_conference_request = null, string $contentType = self::contentTypes['createAConference'][0])
    {
        $account_id = $this->config->getUsername();




        $resourcePath = '/Accounts/{accountId}/Conferences';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_conference_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_conference_request));
            } else {
                $httpBody = $create_conference_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAQueue
     *
     * Create a Queue
     *

     * @param  \FreeClimb\Api\Model\QueueRequest $queue_request Queue details used to create a queue (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAQueue'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\QueueResult
     */
    public function createAQueue($queue_request = null, string $contentType = self::contentTypes['createAQueue'][0])
    {
        list($response) = $this->createAQueueWithHttpInfo($queue_request, $contentType);
        return $response;
    }     
    /**
     * Operation createAQueueWithHttpInfo
     *
     * Create a Queue
     *

     * @param  \FreeClimb\Api\Model\QueueRequest $queue_request Queue details used to create a queue (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAQueue'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\QueueResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAQueueWithHttpInfo($queue_request = null, string $contentType = self::contentTypes['createAQueue'][0])
    {
        $request = $this->createAQueueRequest($queue_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\QueueResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\QueueResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\QueueResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\QueueResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\QueueResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAQueueAsync
     *
     * Create a Queue
     *

     * @param  \FreeClimb\Api\Model\QueueRequest $queue_request Queue details used to create a queue (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAQueueAsync($queue_request = null, string $contentType = self::contentTypes['createAQueue'][0])
    {
        return $this->createAQueueAsyncWithHttpInfo($queue_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAQueueAsyncWithHttpInfo
     *
     * Create a Queue
     *

     * @param  \FreeClimb\Api\Model\QueueRequest $queue_request Queue details used to create a queue (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAQueueAsyncWithHttpInfo($queue_request = null, string $contentType = self::contentTypes['createAQueue'][0])
    {
        $returnType = '\FreeClimb\Api\Model\QueueResult';
        $request = $this->createAQueueRequest($queue_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAQueue'
     *

     * @param  \FreeClimb\Api\Model\QueueRequest $queue_request Queue details used to create a queue (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAQueueRequest($queue_request = null, string $contentType = self::contentTypes['createAQueue'][0])
    {
        $account_id = $this->config->getUsername();




        $resourcePath = '/Accounts/{accountId}/Queues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($queue_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($queue_request));
            } else {
                $httpBody = $queue_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAnApplication
     *
     * Create an application
     *

     * @param  \FreeClimb\Api\Model\ApplicationRequest $application_request Application Details (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnApplication'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\ApplicationResult
     */
    public function createAnApplication($application_request = null, string $contentType = self::contentTypes['createAnApplication'][0])
    {
        list($response) = $this->createAnApplicationWithHttpInfo($application_request, $contentType);
        return $response;
    }     
    /**
     * Operation createAnApplicationWithHttpInfo
     *
     * Create an application
     *

     * @param  \FreeClimb\Api\Model\ApplicationRequest $application_request Application Details (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnApplication'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\ApplicationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAnApplicationWithHttpInfo($application_request = null, string $contentType = self::contentTypes['createAnApplication'][0])
    {
        $request = $this->createAnApplicationRequest($application_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 201:
                    if ('\FreeClimb\Api\Model\ApplicationResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\ApplicationResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\ApplicationResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\ApplicationResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\ApplicationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAnApplicationAsync
     *
     * Create an application
     *

     * @param  \FreeClimb\Api\Model\ApplicationRequest $application_request Application Details (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnApplication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAnApplicationAsync($application_request = null, string $contentType = self::contentTypes['createAnApplication'][0])
    {
        return $this->createAnApplicationAsyncWithHttpInfo($application_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAnApplicationAsyncWithHttpInfo
     *
     * Create an application
     *

     * @param  \FreeClimb\Api\Model\ApplicationRequest $application_request Application Details (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnApplication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAnApplicationAsyncWithHttpInfo($application_request = null, string $contentType = self::contentTypes['createAnApplication'][0])
    {
        $returnType = '\FreeClimb\Api\Model\ApplicationResult';
        $request = $this->createAnApplicationRequest($application_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAnApplication'
     *

     * @param  \FreeClimb\Api\Model\ApplicationRequest $application_request Application Details (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnApplication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAnApplicationRequest($application_request = null, string $contentType = self::contentTypes['createAnApplication'][0])
    {
        $account_id = $this->config->getUsername();




        $resourcePath = '/Accounts/{accountId}/Applications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($application_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($application_request));
            } else {
                $httpBody = $application_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createKnowledgeBaseCompletion
     *
     * Query the knowledge base
     *

     * @param  string $knowledge_base_id A string that uniquely identifies the KnowledgeBase resource. (required)

     * @param  \FreeClimb\Api\Model\CompletionRequest $completion_request Completion request details (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createKnowledgeBaseCompletion'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\CompletionResult
     */
    public function createKnowledgeBaseCompletion($knowledge_base_id, $completion_request = null, string $contentType = self::contentTypes['createKnowledgeBaseCompletion'][0])
    {
        list($response) = $this->createKnowledgeBaseCompletionWithHttpInfo($knowledge_base_id, $completion_request, $contentType);
        return $response;
    }     
    /**
     * Operation createKnowledgeBaseCompletionWithHttpInfo
     *
     * Query the knowledge base
     *

     * @param  string $knowledge_base_id A string that uniquely identifies the KnowledgeBase resource. (required)

     * @param  \FreeClimb\Api\Model\CompletionRequest $completion_request Completion request details (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createKnowledgeBaseCompletion'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\CompletionResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function createKnowledgeBaseCompletionWithHttpInfo($knowledge_base_id, $completion_request = null, string $contentType = self::contentTypes['createKnowledgeBaseCompletion'][0])
    {
        $request = $this->createKnowledgeBaseCompletionRequest($knowledge_base_id, $completion_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\CompletionResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\CompletionResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\CompletionResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\CompletionResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\CompletionResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createKnowledgeBaseCompletionAsync
     *
     * Query the knowledge base
     *

     * @param  string $knowledge_base_id A string that uniquely identifies the KnowledgeBase resource. (required)

     * @param  \FreeClimb\Api\Model\CompletionRequest $completion_request Completion request details (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createKnowledgeBaseCompletion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKnowledgeBaseCompletionAsync($knowledge_base_id, $completion_request = null, string $contentType = self::contentTypes['createKnowledgeBaseCompletion'][0])
    {
        return $this->createKnowledgeBaseCompletionAsyncWithHttpInfo($knowledge_base_id, $completion_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createKnowledgeBaseCompletionAsyncWithHttpInfo
     *
     * Query the knowledge base
     *

     * @param  string $knowledge_base_id A string that uniquely identifies the KnowledgeBase resource. (required)

     * @param  \FreeClimb\Api\Model\CompletionRequest $completion_request Completion request details (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createKnowledgeBaseCompletion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createKnowledgeBaseCompletionAsyncWithHttpInfo($knowledge_base_id, $completion_request = null, string $contentType = self::contentTypes['createKnowledgeBaseCompletion'][0])
    {
        $returnType = '\FreeClimb\Api\Model\CompletionResult';
        $request = $this->createKnowledgeBaseCompletionRequest($knowledge_base_id, $completion_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createKnowledgeBaseCompletion'
     *

     * @param  string $knowledge_base_id A string that uniquely identifies the KnowledgeBase resource. (required)

     * @param  \FreeClimb\Api\Model\CompletionRequest $completion_request Completion request details (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createKnowledgeBaseCompletion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createKnowledgeBaseCompletionRequest($knowledge_base_id, $completion_request = null, string $contentType = self::contentTypes['createKnowledgeBaseCompletion'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'knowledge_base_id' is set
        if ($knowledge_base_id === null || (is_array($knowledge_base_id) && count($knowledge_base_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $knowledge_base_id when calling createKnowledgeBaseCompletion'
            );
        }




        $resourcePath = '/Accounts/{accountId}/KnowledgeBases/{knowledgeBaseId}/Completion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($knowledge_base_id !== null) {
            $resourcePath = str_replace(
                '{' . 'knowledgeBaseId' . '}',
                ObjectSerializer::toPathValue($knowledge_base_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($completion_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($completion_request));
            } else {
                $httpBody = $completion_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteARecording
     *
     * Delete a Recording
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteARecording'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteARecording($recording_id, string $contentType = self::contentTypes['deleteARecording'][0])
    {
        $this->deleteARecordingWithHttpInfo($recording_id, $contentType);
    }     
    /**
     * Operation deleteARecordingWithHttpInfo
     *
     * Delete a Recording
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteARecording'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteARecordingWithHttpInfo($recording_id, string $contentType = self::contentTypes['deleteARecording'][0])
    {
        $request = $this->deleteARecordingRequest($recording_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteARecordingAsync
     *
     * Delete a Recording
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteARecording'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteARecordingAsync($recording_id, string $contentType = self::contentTypes['deleteARecording'][0])
    {
        return $this->deleteARecordingAsyncWithHttpInfo($recording_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteARecordingAsyncWithHttpInfo
     *
     * Delete a Recording
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteARecording'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteARecordingAsyncWithHttpInfo($recording_id, string $contentType = self::contentTypes['deleteARecording'][0])
    {
        $returnType = '';
        $request = $this->deleteARecordingRequest($recording_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteARecording'
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteARecording'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteARecordingRequest($recording_id, string $contentType = self::contentTypes['deleteARecording'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'recording_id' is set
        if ($recording_id === null || (is_array($recording_id) && count($recording_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_id when calling deleteARecording'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Recordings/{recordingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($recording_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recordingId' . '}',
                ObjectSerializer::toPathValue($recording_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAnApplication
     *
     * Delete an application
     *

     * @param  string $application_id String that uniquely identifies this application resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnApplication'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAnApplication($application_id, string $contentType = self::contentTypes['deleteAnApplication'][0])
    {
        $this->deleteAnApplicationWithHttpInfo($application_id, $contentType);
    }     
    /**
     * Operation deleteAnApplicationWithHttpInfo
     *
     * Delete an application
     *

     * @param  string $application_id String that uniquely identifies this application resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnApplication'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAnApplicationWithHttpInfo($application_id, string $contentType = self::contentTypes['deleteAnApplication'][0])
    {
        $request = $this->deleteAnApplicationRequest($application_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAnApplicationAsync
     *
     * Delete an application
     *

     * @param  string $application_id String that uniquely identifies this application resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnApplication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAnApplicationAsync($application_id, string $contentType = self::contentTypes['deleteAnApplication'][0])
    {
        return $this->deleteAnApplicationAsyncWithHttpInfo($application_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAnApplicationAsyncWithHttpInfo
     *
     * Delete an application
     *

     * @param  string $application_id String that uniquely identifies this application resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnApplication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAnApplicationAsyncWithHttpInfo($application_id, string $contentType = self::contentTypes['deleteAnApplication'][0])
    {
        $returnType = '';
        $request = $this->deleteAnApplicationRequest($application_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAnApplication'
     *

     * @param  string $application_id String that uniquely identifies this application resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnApplication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAnApplicationRequest($application_id, string $contentType = self::contentTypes['deleteAnApplication'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling deleteAnApplication'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Applications/{applicationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAnIncomingNumber
     *
     * Delete an Incoming Number
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAnIncomingNumber($phone_number_id, string $contentType = self::contentTypes['deleteAnIncomingNumber'][0])
    {
        $this->deleteAnIncomingNumberWithHttpInfo($phone_number_id, $contentType);
    }     
    /**
     * Operation deleteAnIncomingNumberWithHttpInfo
     *
     * Delete an Incoming Number
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAnIncomingNumberWithHttpInfo($phone_number_id, string $contentType = self::contentTypes['deleteAnIncomingNumber'][0])
    {
        $request = $this->deleteAnIncomingNumberRequest($phone_number_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAnIncomingNumberAsync
     *
     * Delete an Incoming Number
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAnIncomingNumberAsync($phone_number_id, string $contentType = self::contentTypes['deleteAnIncomingNumber'][0])
    {
        return $this->deleteAnIncomingNumberAsyncWithHttpInfo($phone_number_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAnIncomingNumberAsyncWithHttpInfo
     *
     * Delete an Incoming Number
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAnIncomingNumberAsyncWithHttpInfo($phone_number_id, string $contentType = self::contentTypes['deleteAnIncomingNumber'][0])
    {
        $returnType = '';
        $request = $this->deleteAnIncomingNumberRequest($phone_number_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAnIncomingNumber'
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAnIncomingNumberRequest($phone_number_id, string $contentType = self::contentTypes['deleteAnIncomingNumber'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'phone_number_id' is set
        if ($phone_number_id === null || (is_array($phone_number_id) && count($phone_number_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phone_number_id when calling deleteAnIncomingNumber'
            );
        }



        $resourcePath = '/Accounts/{accountId}/IncomingPhoneNumbers/{phoneNumberId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($phone_number_id !== null) {
            $resourcePath = str_replace(
                '{' . 'phoneNumberId' . '}',
                ObjectSerializer::toPathValue($phone_number_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dequeueAMember
     *
     * Dequeue a Member
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $call_id ID if the Call that the Member belongs to (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dequeueAMember'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\QueueMember
     */
    public function dequeueAMember($queue_id, $call_id, string $contentType = self::contentTypes['dequeueAMember'][0])
    {
        list($response) = $this->dequeueAMemberWithHttpInfo($queue_id, $call_id, $contentType);
        return $response;
    }     
    /**
     * Operation dequeueAMemberWithHttpInfo
     *
     * Dequeue a Member
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $call_id ID if the Call that the Member belongs to (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dequeueAMember'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\QueueMember, HTTP status code, HTTP response headers (array of strings)
     */
    public function dequeueAMemberWithHttpInfo($queue_id, $call_id, string $contentType = self::contentTypes['dequeueAMember'][0])
    {
        $request = $this->dequeueAMemberRequest($queue_id, $call_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 202:
                    if ('\FreeClimb\Api\Model\QueueMember' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\QueueMember' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\QueueMember', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\QueueMember';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\QueueMember',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dequeueAMemberAsync
     *
     * Dequeue a Member
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $call_id ID if the Call that the Member belongs to (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dequeueAMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dequeueAMemberAsync($queue_id, $call_id, string $contentType = self::contentTypes['dequeueAMember'][0])
    {
        return $this->dequeueAMemberAsyncWithHttpInfo($queue_id, $call_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dequeueAMemberAsyncWithHttpInfo
     *
     * Dequeue a Member
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $call_id ID if the Call that the Member belongs to (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dequeueAMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dequeueAMemberAsyncWithHttpInfo($queue_id, $call_id, string $contentType = self::contentTypes['dequeueAMember'][0])
    {
        $returnType = '\FreeClimb\Api\Model\QueueMember';
        $request = $this->dequeueAMemberRequest($queue_id, $call_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dequeueAMember'
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $call_id ID if the Call that the Member belongs to (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dequeueAMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dequeueAMemberRequest($queue_id, $call_id, string $contentType = self::contentTypes['dequeueAMember'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'queue_id' is set
        if ($queue_id === null || (is_array($queue_id) && count($queue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_id when calling dequeueAMember'
            );
        }

        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling dequeueAMember'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Queues/{queueId}/Members/{callId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($queue_id !== null) {
            $resourcePath = str_replace(
                '{' . 'queueId' . '}',
                ObjectSerializer::toPathValue($queue_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dequeueHeadMember
     *
     * Dequeue Head Member
     *

     * @param  string $queue_id String that uniquely identifies this queue resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dequeueHeadMember'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\QueueMember
     */
    public function dequeueHeadMember($queue_id, string $contentType = self::contentTypes['dequeueHeadMember'][0])
    {
        list($response) = $this->dequeueHeadMemberWithHttpInfo($queue_id, $contentType);
        return $response;
    }     
    /**
     * Operation dequeueHeadMemberWithHttpInfo
     *
     * Dequeue Head Member
     *

     * @param  string $queue_id String that uniquely identifies this queue resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dequeueHeadMember'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\QueueMember, HTTP status code, HTTP response headers (array of strings)
     */
    public function dequeueHeadMemberWithHttpInfo($queue_id, string $contentType = self::contentTypes['dequeueHeadMember'][0])
    {
        $request = $this->dequeueHeadMemberRequest($queue_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 202:
                    if ('\FreeClimb\Api\Model\QueueMember' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\QueueMember' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\QueueMember', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\QueueMember';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\QueueMember',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dequeueHeadMemberAsync
     *
     * Dequeue Head Member
     *

     * @param  string $queue_id String that uniquely identifies this queue resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dequeueHeadMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dequeueHeadMemberAsync($queue_id, string $contentType = self::contentTypes['dequeueHeadMember'][0])
    {
        return $this->dequeueHeadMemberAsyncWithHttpInfo($queue_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dequeueHeadMemberAsyncWithHttpInfo
     *
     * Dequeue Head Member
     *

     * @param  string $queue_id String that uniquely identifies this queue resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dequeueHeadMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dequeueHeadMemberAsyncWithHttpInfo($queue_id, string $contentType = self::contentTypes['dequeueHeadMember'][0])
    {
        $returnType = '\FreeClimb\Api\Model\QueueMember';
        $request = $this->dequeueHeadMemberRequest($queue_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dequeueHeadMember'
     *

     * @param  string $queue_id String that uniquely identifies this queue resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dequeueHeadMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dequeueHeadMemberRequest($queue_id, string $contentType = self::contentTypes['dequeueHeadMember'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'queue_id' is set
        if ($queue_id === null || (is_array($queue_id) && count($queue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_id when calling dequeueHeadMember'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Queues/{queueId}/Members/Front';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($queue_id !== null) {
            $resourcePath = str_replace(
                '{' . 'queueId' . '}',
                ObjectSerializer::toPathValue($queue_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadARecordingFile
     *
     * Download a Recording File
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadARecordingFile'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function downloadARecordingFile($recording_id, string $contentType = self::contentTypes['downloadARecordingFile'][0])
    {
        list($response) = $this->downloadARecordingFileWithHttpInfo($recording_id, $contentType);
        return $response;
    }     
    /**
     * Operation downloadARecordingFileWithHttpInfo
     *
     * Download a Recording File
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadARecordingFile'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadARecordingFileWithHttpInfo($recording_id, string $contentType = self::contentTypes['downloadARecordingFile'][0])
    {
        $request = $this->downloadARecordingFileRequest($recording_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadARecordingFileAsync
     *
     * Download a Recording File
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadARecordingFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadARecordingFileAsync($recording_id, string $contentType = self::contentTypes['downloadARecordingFile'][0])
    {
        return $this->downloadARecordingFileAsyncWithHttpInfo($recording_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadARecordingFileAsyncWithHttpInfo
     *
     * Download a Recording File
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadARecordingFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadARecordingFileAsyncWithHttpInfo($recording_id, string $contentType = self::contentTypes['downloadARecordingFile'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->downloadARecordingFileRequest($recording_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadARecordingFile'
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadARecordingFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadARecordingFileRequest($recording_id, string $contentType = self::contentTypes['downloadARecordingFile'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'recording_id' is set
        if ($recording_id === null || (is_array($recording_id) && count($recording_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_id when calling downloadARecordingFile'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Recordings/{recordingId}/Download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($recording_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recordingId' . '}',
                ObjectSerializer::toPathValue($recording_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['audio/x-wav', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation filterLogs
     *
     * Filter Logs
     *

     * @param  \FreeClimb\Api\Model\FilterLogsRequest $filter_logs_request Filter logs request paramters (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['filterLogs'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\LogList
     */
    public function filterLogs($filter_logs_request, string $contentType = self::contentTypes['filterLogs'][0])
    {
        list($response) = $this->filterLogsWithHttpInfo($filter_logs_request, $contentType);
        return $response;
    }     
    /**
     * Operation filterLogsWithHttpInfo
     *
     * Filter Logs
     *

     * @param  \FreeClimb\Api\Model\FilterLogsRequest $filter_logs_request Filter logs request paramters (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['filterLogs'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\LogList, HTTP status code, HTTP response headers (array of strings)
     */
    public function filterLogsWithHttpInfo($filter_logs_request, string $contentType = self::contentTypes['filterLogs'][0])
    {
        $request = $this->filterLogsRequest($filter_logs_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\LogList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\LogList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\LogList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\LogList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\LogList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation filterLogsAsync
     *
     * Filter Logs
     *

     * @param  \FreeClimb\Api\Model\FilterLogsRequest $filter_logs_request Filter logs request paramters (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['filterLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filterLogsAsync($filter_logs_request, string $contentType = self::contentTypes['filterLogs'][0])
    {
        return $this->filterLogsAsyncWithHttpInfo($filter_logs_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation filterLogsAsyncWithHttpInfo
     *
     * Filter Logs
     *

     * @param  \FreeClimb\Api\Model\FilterLogsRequest $filter_logs_request Filter logs request paramters (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['filterLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filterLogsAsyncWithHttpInfo($filter_logs_request, string $contentType = self::contentTypes['filterLogs'][0])
    {
        $returnType = '\FreeClimb\Api\Model\LogList';
        $request = $this->filterLogsRequest($filter_logs_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'filterLogs'
     *

     * @param  \FreeClimb\Api\Model\FilterLogsRequest $filter_logs_request Filter logs request paramters (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['filterLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function filterLogsRequest($filter_logs_request, string $contentType = self::contentTypes['filterLogs'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'filter_logs_request' is set
        if ($filter_logs_request === null || (is_array($filter_logs_request) && count($filter_logs_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filter_logs_request when calling filterLogs'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($filter_logs_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($filter_logs_request));
            } else {
                $httpBody = $filter_logs_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getACall
     *
     * Get a Call
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACall'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\CallResult
     */
    public function getACall($call_id, string $contentType = self::contentTypes['getACall'][0])
    {
        list($response) = $this->getACallWithHttpInfo($call_id, $contentType);
        return $response;
    }     
    /**
     * Operation getACallWithHttpInfo
     *
     * Get a Call
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACall'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\CallResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getACallWithHttpInfo($call_id, string $contentType = self::contentTypes['getACall'][0])
    {
        $request = $this->getACallRequest($call_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\CallResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\CallResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\CallResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\CallResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\CallResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getACallAsync
     *
     * Get a Call
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACall'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACallAsync($call_id, string $contentType = self::contentTypes['getACall'][0])
    {
        return $this->getACallAsyncWithHttpInfo($call_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getACallAsyncWithHttpInfo
     *
     * Get a Call
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACall'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACallAsyncWithHttpInfo($call_id, string $contentType = self::contentTypes['getACall'][0])
    {
        $returnType = '\FreeClimb\Api\Model\CallResult';
        $request = $this->getACallRequest($call_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getACall'
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACall'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getACallRequest($call_id, string $contentType = self::contentTypes['getACall'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling getACall'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Calls/{callId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAConference
     *
     * Get a Conference
     *

     * @param  string $conference_id A string that uniquely identifies this conference resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAConference'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\ConferenceResult
     */
    public function getAConference($conference_id, string $contentType = self::contentTypes['getAConference'][0])
    {
        list($response) = $this->getAConferenceWithHttpInfo($conference_id, $contentType);
        return $response;
    }     
    /**
     * Operation getAConferenceWithHttpInfo
     *
     * Get a Conference
     *

     * @param  string $conference_id A string that uniquely identifies this conference resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAConference'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\ConferenceResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAConferenceWithHttpInfo($conference_id, string $contentType = self::contentTypes['getAConference'][0])
    {
        $request = $this->getAConferenceRequest($conference_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\ConferenceResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\ConferenceResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\ConferenceResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\ConferenceResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\ConferenceResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAConferenceAsync
     *
     * Get a Conference
     *

     * @param  string $conference_id A string that uniquely identifies this conference resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAConference'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAConferenceAsync($conference_id, string $contentType = self::contentTypes['getAConference'][0])
    {
        return $this->getAConferenceAsyncWithHttpInfo($conference_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAConferenceAsyncWithHttpInfo
     *
     * Get a Conference
     *

     * @param  string $conference_id A string that uniquely identifies this conference resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAConference'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAConferenceAsyncWithHttpInfo($conference_id, string $contentType = self::contentTypes['getAConference'][0])
    {
        $returnType = '\FreeClimb\Api\Model\ConferenceResult';
        $request = $this->getAConferenceRequest($conference_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAConference'
     *

     * @param  string $conference_id A string that uniquely identifies this conference resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAConference'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAConferenceRequest($conference_id, string $contentType = self::contentTypes['getAConference'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'conference_id' is set
        if ($conference_id === null || (is_array($conference_id) && count($conference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_id when calling getAConference'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Conferences/{conferenceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($conference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'conferenceId' . '}',
                ObjectSerializer::toPathValue($conference_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAMember
     *
     * Get a Member
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $call_id ID of the Call that the Member belongs to (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAMember'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\QueueMember
     */
    public function getAMember($queue_id, $call_id, string $contentType = self::contentTypes['getAMember'][0])
    {
        list($response) = $this->getAMemberWithHttpInfo($queue_id, $call_id, $contentType);
        return $response;
    }     
    /**
     * Operation getAMemberWithHttpInfo
     *
     * Get a Member
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $call_id ID of the Call that the Member belongs to (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAMember'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\QueueMember, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAMemberWithHttpInfo($queue_id, $call_id, string $contentType = self::contentTypes['getAMember'][0])
    {
        $request = $this->getAMemberRequest($queue_id, $call_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\QueueMember' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\QueueMember' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\QueueMember', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\QueueMember';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\QueueMember',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAMemberAsync
     *
     * Get a Member
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $call_id ID of the Call that the Member belongs to (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAMemberAsync($queue_id, $call_id, string $contentType = self::contentTypes['getAMember'][0])
    {
        return $this->getAMemberAsyncWithHttpInfo($queue_id, $call_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAMemberAsyncWithHttpInfo
     *
     * Get a Member
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $call_id ID of the Call that the Member belongs to (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAMemberAsyncWithHttpInfo($queue_id, $call_id, string $contentType = self::contentTypes['getAMember'][0])
    {
        $returnType = '\FreeClimb\Api\Model\QueueMember';
        $request = $this->getAMemberRequest($queue_id, $call_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAMember'
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $call_id ID of the Call that the Member belongs to (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAMemberRequest($queue_id, $call_id, string $contentType = self::contentTypes['getAMember'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'queue_id' is set
        if ($queue_id === null || (is_array($queue_id) && count($queue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_id when calling getAMember'
            );
        }

        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling getAMember'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Queues/{queueId}/Members/{callId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($queue_id !== null) {
            $resourcePath = str_replace(
                '{' . 'queueId' . '}',
                ObjectSerializer::toPathValue($queue_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAParticipant
     *
     * Get a Participant
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAParticipant'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\ConferenceParticipantResult
     */
    public function getAParticipant($conference_id, $call_id, string $contentType = self::contentTypes['getAParticipant'][0])
    {
        list($response) = $this->getAParticipantWithHttpInfo($conference_id, $call_id, $contentType);
        return $response;
    }     
    /**
     * Operation getAParticipantWithHttpInfo
     *
     * Get a Participant
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAParticipant'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\ConferenceParticipantResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAParticipantWithHttpInfo($conference_id, $call_id, string $contentType = self::contentTypes['getAParticipant'][0])
    {
        $request = $this->getAParticipantRequest($conference_id, $call_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\ConferenceParticipantResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\ConferenceParticipantResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\ConferenceParticipantResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\ConferenceParticipantResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\ConferenceParticipantResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAParticipantAsync
     *
     * Get a Participant
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAParticipant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAParticipantAsync($conference_id, $call_id, string $contentType = self::contentTypes['getAParticipant'][0])
    {
        return $this->getAParticipantAsyncWithHttpInfo($conference_id, $call_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAParticipantAsyncWithHttpInfo
     *
     * Get a Participant
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAParticipant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAParticipantAsyncWithHttpInfo($conference_id, $call_id, string $contentType = self::contentTypes['getAParticipant'][0])
    {
        $returnType = '\FreeClimb\Api\Model\ConferenceParticipantResult';
        $request = $this->getAParticipantRequest($conference_id, $call_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAParticipant'
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAParticipant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAParticipantRequest($conference_id, $call_id, string $contentType = self::contentTypes['getAParticipant'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'conference_id' is set
        if ($conference_id === null || (is_array($conference_id) && count($conference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_id when calling getAParticipant'
            );
        }

        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling getAParticipant'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Conferences/{conferenceId}/Participants/{callId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($conference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'conferenceId' . '}',
                ObjectSerializer::toPathValue($conference_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAQueue
     *
     * Get a Queue
     *

     * @param  string $queue_id A string that uniquely identifies this queue resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAQueue'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\QueueResult
     */
    public function getAQueue($queue_id, string $contentType = self::contentTypes['getAQueue'][0])
    {
        list($response) = $this->getAQueueWithHttpInfo($queue_id, $contentType);
        return $response;
    }     
    /**
     * Operation getAQueueWithHttpInfo
     *
     * Get a Queue
     *

     * @param  string $queue_id A string that uniquely identifies this queue resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAQueue'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\QueueResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAQueueWithHttpInfo($queue_id, string $contentType = self::contentTypes['getAQueue'][0])
    {
        $request = $this->getAQueueRequest($queue_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\QueueResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\QueueResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\QueueResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\QueueResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\QueueResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAQueueAsync
     *
     * Get a Queue
     *

     * @param  string $queue_id A string that uniquely identifies this queue resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAQueueAsync($queue_id, string $contentType = self::contentTypes['getAQueue'][0])
    {
        return $this->getAQueueAsyncWithHttpInfo($queue_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAQueueAsyncWithHttpInfo
     *
     * Get a Queue
     *

     * @param  string $queue_id A string that uniquely identifies this queue resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAQueueAsyncWithHttpInfo($queue_id, string $contentType = self::contentTypes['getAQueue'][0])
    {
        $returnType = '\FreeClimb\Api\Model\QueueResult';
        $request = $this->getAQueueRequest($queue_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAQueue'
     *

     * @param  string $queue_id A string that uniquely identifies this queue resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAQueueRequest($queue_id, string $contentType = self::contentTypes['getAQueue'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'queue_id' is set
        if ($queue_id === null || (is_array($queue_id) && count($queue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_id when calling getAQueue'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Queues/{queueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($queue_id !== null) {
            $resourcePath = str_replace(
                '{' . 'queueId' . '}',
                ObjectSerializer::toPathValue($queue_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getARecording
     *
     * Get a Recording
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getARecording'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\RecordingResult
     */
    public function getARecording($recording_id, string $contentType = self::contentTypes['getARecording'][0])
    {
        list($response) = $this->getARecordingWithHttpInfo($recording_id, $contentType);
        return $response;
    }     
    /**
     * Operation getARecordingWithHttpInfo
     *
     * Get a Recording
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getARecording'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\RecordingResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getARecordingWithHttpInfo($recording_id, string $contentType = self::contentTypes['getARecording'][0])
    {
        $request = $this->getARecordingRequest($recording_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\RecordingResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\RecordingResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\RecordingResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\RecordingResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\RecordingResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getARecordingAsync
     *
     * Get a Recording
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getARecording'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getARecordingAsync($recording_id, string $contentType = self::contentTypes['getARecording'][0])
    {
        return $this->getARecordingAsyncWithHttpInfo($recording_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getARecordingAsyncWithHttpInfo
     *
     * Get a Recording
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getARecording'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getARecordingAsyncWithHttpInfo($recording_id, string $contentType = self::contentTypes['getARecording'][0])
    {
        $returnType = '\FreeClimb\Api\Model\RecordingResult';
        $request = $this->getARecordingRequest($recording_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getARecording'
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getARecording'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getARecordingRequest($recording_id, string $contentType = self::contentTypes['getARecording'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'recording_id' is set
        if ($recording_id === null || (is_array($recording_id) && count($recording_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_id when calling getARecording'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Recordings/{recordingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($recording_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recordingId' . '}',
                ObjectSerializer::toPathValue($recording_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnAccount
     *
     * Get an Account
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnAccount'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\AccountResult
     */
    public function getAnAccount(string $contentType = self::contentTypes['getAnAccount'][0])
    {
        list($response) = $this->getAnAccountWithHttpInfo($contentType);
        return $response;
    }     
    /**
     * Operation getAnAccountWithHttpInfo
     *
     * Get an Account
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnAccount'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\AccountResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnAccountWithHttpInfo(string $contentType = self::contentTypes['getAnAccount'][0])
    {
        $request = $this->getAnAccountRequest($contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\AccountResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\AccountResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\AccountResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\AccountResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\AccountResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnAccountAsync
     *
     * Get an Account
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnAccountAsync(string $contentType = self::contentTypes['getAnAccount'][0])
    {
        return $this->getAnAccountAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnAccountAsyncWithHttpInfo
     *
     * Get an Account
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnAccountAsyncWithHttpInfo(string $contentType = self::contentTypes['getAnAccount'][0])
    {
        $returnType = '\FreeClimb\Api\Model\AccountResult';
        $request = $this->getAnAccountRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnAccount'
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAnAccountRequest(string $contentType = self::contentTypes['getAnAccount'][0])
    {
        $account_id = $this->config->getUsername();



        $resourcePath = '/Accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnApplication
     *
     * Get an Application
     *

     * @param  string $application_id A string that uniquely identifies this application resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnApplication'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\ApplicationResult
     */
    public function getAnApplication($application_id, string $contentType = self::contentTypes['getAnApplication'][0])
    {
        list($response) = $this->getAnApplicationWithHttpInfo($application_id, $contentType);
        return $response;
    }     
    /**
     * Operation getAnApplicationWithHttpInfo
     *
     * Get an Application
     *

     * @param  string $application_id A string that uniquely identifies this application resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnApplication'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\ApplicationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnApplicationWithHttpInfo($application_id, string $contentType = self::contentTypes['getAnApplication'][0])
    {
        $request = $this->getAnApplicationRequest($application_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\ApplicationResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\ApplicationResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\ApplicationResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\ApplicationResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\ApplicationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnApplicationAsync
     *
     * Get an Application
     *

     * @param  string $application_id A string that uniquely identifies this application resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnApplication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnApplicationAsync($application_id, string $contentType = self::contentTypes['getAnApplication'][0])
    {
        return $this->getAnApplicationAsyncWithHttpInfo($application_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnApplicationAsyncWithHttpInfo
     *
     * Get an Application
     *

     * @param  string $application_id A string that uniquely identifies this application resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnApplication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnApplicationAsyncWithHttpInfo($application_id, string $contentType = self::contentTypes['getAnApplication'][0])
    {
        $returnType = '\FreeClimb\Api\Model\ApplicationResult';
        $request = $this->getAnApplicationRequest($application_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnApplication'
     *

     * @param  string $application_id A string that uniquely identifies this application resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnApplication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAnApplicationRequest($application_id, string $contentType = self::contentTypes['getAnApplication'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getAnApplication'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Applications/{applicationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnIncomingNumber
     *
     * Get an Incoming Number
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\IncomingNumberResult
     */
    public function getAnIncomingNumber($phone_number_id, string $contentType = self::contentTypes['getAnIncomingNumber'][0])
    {
        list($response) = $this->getAnIncomingNumberWithHttpInfo($phone_number_id, $contentType);
        return $response;
    }     
    /**
     * Operation getAnIncomingNumberWithHttpInfo
     *
     * Get an Incoming Number
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\IncomingNumberResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnIncomingNumberWithHttpInfo($phone_number_id, string $contentType = self::contentTypes['getAnIncomingNumber'][0])
    {
        $request = $this->getAnIncomingNumberRequest($phone_number_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\IncomingNumberResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\IncomingNumberResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\IncomingNumberResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\IncomingNumberResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\IncomingNumberResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnIncomingNumberAsync
     *
     * Get an Incoming Number
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnIncomingNumberAsync($phone_number_id, string $contentType = self::contentTypes['getAnIncomingNumber'][0])
    {
        return $this->getAnIncomingNumberAsyncWithHttpInfo($phone_number_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnIncomingNumberAsyncWithHttpInfo
     *
     * Get an Incoming Number
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnIncomingNumberAsyncWithHttpInfo($phone_number_id, string $contentType = self::contentTypes['getAnIncomingNumber'][0])
    {
        $returnType = '\FreeClimb\Api\Model\IncomingNumberResult';
        $request = $this->getAnIncomingNumberRequest($phone_number_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnIncomingNumber'
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAnIncomingNumberRequest($phone_number_id, string $contentType = self::contentTypes['getAnIncomingNumber'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'phone_number_id' is set
        if ($phone_number_id === null || (is_array($phone_number_id) && count($phone_number_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phone_number_id when calling getAnIncomingNumber'
            );
        }



        $resourcePath = '/Accounts/{accountId}/IncomingPhoneNumbers/{phoneNumberId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($phone_number_id !== null) {
            $resourcePath = str_replace(
                '{' . 'phoneNumberId' . '}',
                ObjectSerializer::toPathValue($phone_number_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnSmsMessage
     *
     * Get an SMS Message
     *

     * @param  string $message_id String that uniquely identifies this Message resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnSmsMessage'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\MessageResult
     */
    public function getAnSmsMessage($message_id, string $contentType = self::contentTypes['getAnSmsMessage'][0])
    {
        list($response) = $this->getAnSmsMessageWithHttpInfo($message_id, $contentType);
        return $response;
    }     
    /**
     * Operation getAnSmsMessageWithHttpInfo
     *
     * Get an SMS Message
     *

     * @param  string $message_id String that uniquely identifies this Message resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnSmsMessage'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\MessageResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnSmsMessageWithHttpInfo($message_id, string $contentType = self::contentTypes['getAnSmsMessage'][0])
    {
        $request = $this->getAnSmsMessageRequest($message_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\MessageResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\MessageResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\MessageResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\MessageResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\MessageResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnSmsMessageAsync
     *
     * Get an SMS Message
     *

     * @param  string $message_id String that uniquely identifies this Message resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnSmsMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnSmsMessageAsync($message_id, string $contentType = self::contentTypes['getAnSmsMessage'][0])
    {
        return $this->getAnSmsMessageAsyncWithHttpInfo($message_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnSmsMessageAsyncWithHttpInfo
     *
     * Get an SMS Message
     *

     * @param  string $message_id String that uniquely identifies this Message resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnSmsMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnSmsMessageAsyncWithHttpInfo($message_id, string $contentType = self::contentTypes['getAnSmsMessage'][0])
    {
        $returnType = '\FreeClimb\Api\Model\MessageResult';
        $request = $this->getAnSmsMessageRequest($message_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnSmsMessage'
     *

     * @param  string $message_id String that uniquely identifies this Message resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnSmsMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAnSmsMessageRequest($message_id, string $contentType = self::contentTypes['getAnSmsMessage'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling getAnSmsMessage'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Messages/{messageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'messageId' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHeadMember
     *
     * Get Head Member
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHeadMember'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\QueueMember
     */
    public function getHeadMember($queue_id, string $contentType = self::contentTypes['getHeadMember'][0])
    {
        list($response) = $this->getHeadMemberWithHttpInfo($queue_id, $contentType);
        return $response;
    }     
    /**
     * Operation getHeadMemberWithHttpInfo
     *
     * Get Head Member
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHeadMember'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\QueueMember, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHeadMemberWithHttpInfo($queue_id, string $contentType = self::contentTypes['getHeadMember'][0])
    {
        $request = $this->getHeadMemberRequest($queue_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\QueueMember' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\QueueMember' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\QueueMember', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\QueueMember';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\QueueMember',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHeadMemberAsync
     *
     * Get Head Member
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHeadMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHeadMemberAsync($queue_id, string $contentType = self::contentTypes['getHeadMember'][0])
    {
        return $this->getHeadMemberAsyncWithHttpInfo($queue_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHeadMemberAsyncWithHttpInfo
     *
     * Get Head Member
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHeadMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHeadMemberAsyncWithHttpInfo($queue_id, string $contentType = self::contentTypes['getHeadMember'][0])
    {
        $returnType = '\FreeClimb\Api\Model\QueueMember';
        $request = $this->getHeadMemberRequest($queue_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHeadMember'
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHeadMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getHeadMemberRequest($queue_id, string $contentType = self::contentTypes['getHeadMember'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'queue_id' is set
        if ($queue_id === null || (is_array($queue_id) && count($queue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_id when calling getHeadMember'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Queues/{queueId}/Members/Front';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($queue_id !== null) {
            $resourcePath = str_replace(
                '{' . 'queueId' . '}',
                ObjectSerializer::toPathValue($queue_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTenDLCSmsBrand
     *
     * Get a 10DLC SMS Brand
     *

     * @param  string $brand_id String that uniquely identifies this brand resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsBrand'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\SMSTenDLCBrand
     */
    public function getTenDLCSmsBrand($brand_id, string $contentType = self::contentTypes['getTenDLCSmsBrand'][0])
    {
        list($response) = $this->getTenDLCSmsBrandWithHttpInfo($brand_id, $contentType);
        return $response;
    }     
    /**
     * Operation getTenDLCSmsBrandWithHttpInfo
     *
     * Get a 10DLC SMS Brand
     *

     * @param  string $brand_id String that uniquely identifies this brand resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsBrand'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\SMSTenDLCBrand, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTenDLCSmsBrandWithHttpInfo($brand_id, string $contentType = self::contentTypes['getTenDLCSmsBrand'][0])
    {
        $request = $this->getTenDLCSmsBrandRequest($brand_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\SMSTenDLCBrand' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\SMSTenDLCBrand' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\SMSTenDLCBrand', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\SMSTenDLCBrand';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\SMSTenDLCBrand',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTenDLCSmsBrandAsync
     *
     * Get a 10DLC SMS Brand
     *

     * @param  string $brand_id String that uniquely identifies this brand resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenDLCSmsBrandAsync($brand_id, string $contentType = self::contentTypes['getTenDLCSmsBrand'][0])
    {
        return $this->getTenDLCSmsBrandAsyncWithHttpInfo($brand_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTenDLCSmsBrandAsyncWithHttpInfo
     *
     * Get a 10DLC SMS Brand
     *

     * @param  string $brand_id String that uniquely identifies this brand resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenDLCSmsBrandAsyncWithHttpInfo($brand_id, string $contentType = self::contentTypes['getTenDLCSmsBrand'][0])
    {
        $returnType = '\FreeClimb\Api\Model\SMSTenDLCBrand';
        $request = $this->getTenDLCSmsBrandRequest($brand_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTenDLCSmsBrand'
     *

     * @param  string $brand_id String that uniquely identifies this brand resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTenDLCSmsBrandRequest($brand_id, string $contentType = self::contentTypes['getTenDLCSmsBrand'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'brand_id' is set
        if ($brand_id === null || (is_array($brand_id) && count($brand_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $brand_id when calling getTenDLCSmsBrand'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Messages/10DLC/Brands/{brandId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($brand_id !== null) {
            $resourcePath = str_replace(
                '{' . 'brandId' . '}',
                ObjectSerializer::toPathValue($brand_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTenDLCSmsBrands
     *
     * Get list of SMS 10DLC Brands
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsBrands'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\SMSTenDLCBrandsListResult
     */
    public function getTenDLCSmsBrands(string $contentType = self::contentTypes['getTenDLCSmsBrands'][0])
    {
        list($response) = $this->getTenDLCSmsBrandsWithHttpInfo($contentType);
        return $response;
    }     
    /**
     * Operation getTenDLCSmsBrandsWithHttpInfo
     *
     * Get list of SMS 10DLC Brands
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsBrands'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\SMSTenDLCBrandsListResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTenDLCSmsBrandsWithHttpInfo(string $contentType = self::contentTypes['getTenDLCSmsBrands'][0])
    {
        $request = $this->getTenDLCSmsBrandsRequest($contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\SMSTenDLCBrandsListResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\SMSTenDLCBrandsListResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\SMSTenDLCBrandsListResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\SMSTenDLCBrandsListResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\SMSTenDLCBrandsListResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTenDLCSmsBrandsAsync
     *
     * Get list of SMS 10DLC Brands
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenDLCSmsBrandsAsync(string $contentType = self::contentTypes['getTenDLCSmsBrands'][0])
    {
        return $this->getTenDLCSmsBrandsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTenDLCSmsBrandsAsyncWithHttpInfo
     *
     * Get list of SMS 10DLC Brands
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenDLCSmsBrandsAsyncWithHttpInfo(string $contentType = self::contentTypes['getTenDLCSmsBrands'][0])
    {
        $returnType = '\FreeClimb\Api\Model\SMSTenDLCBrandsListResult';
        $request = $this->getTenDLCSmsBrandsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTenDLCSmsBrands'
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTenDLCSmsBrandsRequest(string $contentType = self::contentTypes['getTenDLCSmsBrands'][0])
    {
        $account_id = $this->config->getUsername();



        $resourcePath = '/Accounts/{accountId}/Messages/10DLC/Brands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTenDLCSmsCampaign
     *
     * Get a 10DLC SMS Campaign
     *

     * @param  string $campaign_id String that uniquely identifies this campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsCampaign'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\SMSTenDLCCampaign
     */
    public function getTenDLCSmsCampaign($campaign_id, string $contentType = self::contentTypes['getTenDLCSmsCampaign'][0])
    {
        list($response) = $this->getTenDLCSmsCampaignWithHttpInfo($campaign_id, $contentType);
        return $response;
    }     
    /**
     * Operation getTenDLCSmsCampaignWithHttpInfo
     *
     * Get a 10DLC SMS Campaign
     *

     * @param  string $campaign_id String that uniquely identifies this campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsCampaign'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\SMSTenDLCCampaign, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTenDLCSmsCampaignWithHttpInfo($campaign_id, string $contentType = self::contentTypes['getTenDLCSmsCampaign'][0])
    {
        $request = $this->getTenDLCSmsCampaignRequest($campaign_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\SMSTenDLCCampaign' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\SMSTenDLCCampaign' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\SMSTenDLCCampaign', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\SMSTenDLCCampaign';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\SMSTenDLCCampaign',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTenDLCSmsCampaignAsync
     *
     * Get a 10DLC SMS Campaign
     *

     * @param  string $campaign_id String that uniquely identifies this campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenDLCSmsCampaignAsync($campaign_id, string $contentType = self::contentTypes['getTenDLCSmsCampaign'][0])
    {
        return $this->getTenDLCSmsCampaignAsyncWithHttpInfo($campaign_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTenDLCSmsCampaignAsyncWithHttpInfo
     *
     * Get a 10DLC SMS Campaign
     *

     * @param  string $campaign_id String that uniquely identifies this campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenDLCSmsCampaignAsyncWithHttpInfo($campaign_id, string $contentType = self::contentTypes['getTenDLCSmsCampaign'][0])
    {
        $returnType = '\FreeClimb\Api\Model\SMSTenDLCCampaign';
        $request = $this->getTenDLCSmsCampaignRequest($campaign_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTenDLCSmsCampaign'
     *

     * @param  string $campaign_id String that uniquely identifies this campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTenDLCSmsCampaignRequest($campaign_id, string $contentType = self::contentTypes['getTenDLCSmsCampaign'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling getTenDLCSmsCampaign'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Messages/10DLC/Campaigns/{campaignId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTenDLCSmsCampaigns
     *
     * Get list of SMS 10DLC Campaigns
     *

     * @param  string $brand_id The unique identifier for a brand (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsCampaigns'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\SMSTenDLCCampaignsListResult
     */
    public function getTenDLCSmsCampaigns($brand_id = null, string $contentType = self::contentTypes['getTenDLCSmsCampaigns'][0])
    {
        list($response) = $this->getTenDLCSmsCampaignsWithHttpInfo($brand_id, $contentType);
        return $response;
    }     
    /**
     * Operation getTenDLCSmsCampaignsWithHttpInfo
     *
     * Get list of SMS 10DLC Campaigns
     *

     * @param  string $brand_id The unique identifier for a brand (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsCampaigns'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\SMSTenDLCCampaignsListResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTenDLCSmsCampaignsWithHttpInfo($brand_id = null, string $contentType = self::contentTypes['getTenDLCSmsCampaigns'][0])
    {
        $request = $this->getTenDLCSmsCampaignsRequest($brand_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\SMSTenDLCCampaignsListResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\SMSTenDLCCampaignsListResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\SMSTenDLCCampaignsListResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\SMSTenDLCCampaignsListResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\SMSTenDLCCampaignsListResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTenDLCSmsCampaignsAsync
     *
     * Get list of SMS 10DLC Campaigns
     *

     * @param  string $brand_id The unique identifier for a brand (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsCampaigns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenDLCSmsCampaignsAsync($brand_id = null, string $contentType = self::contentTypes['getTenDLCSmsCampaigns'][0])
    {
        return $this->getTenDLCSmsCampaignsAsyncWithHttpInfo($brand_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTenDLCSmsCampaignsAsyncWithHttpInfo
     *
     * Get list of SMS 10DLC Campaigns
     *

     * @param  string $brand_id The unique identifier for a brand (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsCampaigns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenDLCSmsCampaignsAsyncWithHttpInfo($brand_id = null, string $contentType = self::contentTypes['getTenDLCSmsCampaigns'][0])
    {
        $returnType = '\FreeClimb\Api\Model\SMSTenDLCCampaignsListResult';
        $request = $this->getTenDLCSmsCampaignsRequest($brand_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTenDLCSmsCampaigns'
     *

     * @param  string $brand_id The unique identifier for a brand (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsCampaigns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTenDLCSmsCampaignsRequest($brand_id = null, string $contentType = self::contentTypes['getTenDLCSmsCampaigns'][0])
    {
        $account_id = $this->config->getUsername();




        $resourcePath = '/Accounts/{accountId}/Messages/10DLC/Campaigns';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brand_id,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTenDLCSmsPartnerCampaign
     *
     * Get a 10DLC SMS Partner Campaign
     *

     * @param  string $campaign_id String that uniquely identifies this campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsPartnerCampaign'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\SMSTenDLCPartnerCampaign
     */
    public function getTenDLCSmsPartnerCampaign($campaign_id, string $contentType = self::contentTypes['getTenDLCSmsPartnerCampaign'][0])
    {
        list($response) = $this->getTenDLCSmsPartnerCampaignWithHttpInfo($campaign_id, $contentType);
        return $response;
    }     
    /**
     * Operation getTenDLCSmsPartnerCampaignWithHttpInfo
     *
     * Get a 10DLC SMS Partner Campaign
     *

     * @param  string $campaign_id String that uniquely identifies this campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsPartnerCampaign'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\SMSTenDLCPartnerCampaign, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTenDLCSmsPartnerCampaignWithHttpInfo($campaign_id, string $contentType = self::contentTypes['getTenDLCSmsPartnerCampaign'][0])
    {
        $request = $this->getTenDLCSmsPartnerCampaignRequest($campaign_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\SMSTenDLCPartnerCampaign' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\SMSTenDLCPartnerCampaign' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\SMSTenDLCPartnerCampaign', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\SMSTenDLCPartnerCampaign';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\SMSTenDLCPartnerCampaign',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTenDLCSmsPartnerCampaignAsync
     *
     * Get a 10DLC SMS Partner Campaign
     *

     * @param  string $campaign_id String that uniquely identifies this campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsPartnerCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenDLCSmsPartnerCampaignAsync($campaign_id, string $contentType = self::contentTypes['getTenDLCSmsPartnerCampaign'][0])
    {
        return $this->getTenDLCSmsPartnerCampaignAsyncWithHttpInfo($campaign_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTenDLCSmsPartnerCampaignAsyncWithHttpInfo
     *
     * Get a 10DLC SMS Partner Campaign
     *

     * @param  string $campaign_id String that uniquely identifies this campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsPartnerCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenDLCSmsPartnerCampaignAsyncWithHttpInfo($campaign_id, string $contentType = self::contentTypes['getTenDLCSmsPartnerCampaign'][0])
    {
        $returnType = '\FreeClimb\Api\Model\SMSTenDLCPartnerCampaign';
        $request = $this->getTenDLCSmsPartnerCampaignRequest($campaign_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTenDLCSmsPartnerCampaign'
     *

     * @param  string $campaign_id String that uniquely identifies this campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsPartnerCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTenDLCSmsPartnerCampaignRequest($campaign_id, string $contentType = self::contentTypes['getTenDLCSmsPartnerCampaign'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling getTenDLCSmsPartnerCampaign'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Messages/10DLC/PartnerCampaigns/{campaignId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTenDLCSmsPartnerCampaigns
     *
     * Get list of SMS 10DLC Partner Campaigns
     *

     * @param  string $brand_id The unique identifier for a brand (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsPartnerCampaigns'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\SMSTenDLCPartnerCampaignsListResult
     */
    public function getTenDLCSmsPartnerCampaigns($brand_id = null, string $contentType = self::contentTypes['getTenDLCSmsPartnerCampaigns'][0])
    {
        list($response) = $this->getTenDLCSmsPartnerCampaignsWithHttpInfo($brand_id, $contentType);
        return $response;
    }     
    /**
     * Operation getTenDLCSmsPartnerCampaignsWithHttpInfo
     *
     * Get list of SMS 10DLC Partner Campaigns
     *

     * @param  string $brand_id The unique identifier for a brand (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsPartnerCampaigns'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\SMSTenDLCPartnerCampaignsListResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTenDLCSmsPartnerCampaignsWithHttpInfo($brand_id = null, string $contentType = self::contentTypes['getTenDLCSmsPartnerCampaigns'][0])
    {
        $request = $this->getTenDLCSmsPartnerCampaignsRequest($brand_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\SMSTenDLCPartnerCampaignsListResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\SMSTenDLCPartnerCampaignsListResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\SMSTenDLCPartnerCampaignsListResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\SMSTenDLCPartnerCampaignsListResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\SMSTenDLCPartnerCampaignsListResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTenDLCSmsPartnerCampaignsAsync
     *
     * Get list of SMS 10DLC Partner Campaigns
     *

     * @param  string $brand_id The unique identifier for a brand (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsPartnerCampaigns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenDLCSmsPartnerCampaignsAsync($brand_id = null, string $contentType = self::contentTypes['getTenDLCSmsPartnerCampaigns'][0])
    {
        return $this->getTenDLCSmsPartnerCampaignsAsyncWithHttpInfo($brand_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTenDLCSmsPartnerCampaignsAsyncWithHttpInfo
     *
     * Get list of SMS 10DLC Partner Campaigns
     *

     * @param  string $brand_id The unique identifier for a brand (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsPartnerCampaigns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenDLCSmsPartnerCampaignsAsyncWithHttpInfo($brand_id = null, string $contentType = self::contentTypes['getTenDLCSmsPartnerCampaigns'][0])
    {
        $returnType = '\FreeClimb\Api\Model\SMSTenDLCPartnerCampaignsListResult';
        $request = $this->getTenDLCSmsPartnerCampaignsRequest($brand_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTenDLCSmsPartnerCampaigns'
     *

     * @param  string $brand_id The unique identifier for a brand (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenDLCSmsPartnerCampaigns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTenDLCSmsPartnerCampaignsRequest($brand_id = null, string $contentType = self::contentTypes['getTenDLCSmsPartnerCampaigns'][0])
    {
        $account_id = $this->config->getUsername();




        $resourcePath = '/Accounts/{accountId}/Messages/10DLC/PartnerCampaigns';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brand_id,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTollFreeSmsCampaign
     *
     * Get a TollFree SMS Campaign
     *

     * @param  string $campaign_id String that uniquely identifies this TollFree Campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTollFreeSmsCampaign'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\SMSTollFreeCampaign
     */
    public function getTollFreeSmsCampaign($campaign_id, string $contentType = self::contentTypes['getTollFreeSmsCampaign'][0])
    {
        list($response) = $this->getTollFreeSmsCampaignWithHttpInfo($campaign_id, $contentType);
        return $response;
    }     
    /**
     * Operation getTollFreeSmsCampaignWithHttpInfo
     *
     * Get a TollFree SMS Campaign
     *

     * @param  string $campaign_id String that uniquely identifies this TollFree Campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTollFreeSmsCampaign'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\SMSTollFreeCampaign, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTollFreeSmsCampaignWithHttpInfo($campaign_id, string $contentType = self::contentTypes['getTollFreeSmsCampaign'][0])
    {
        $request = $this->getTollFreeSmsCampaignRequest($campaign_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\SMSTollFreeCampaign' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\SMSTollFreeCampaign' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\SMSTollFreeCampaign', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\SMSTollFreeCampaign';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\SMSTollFreeCampaign',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTollFreeSmsCampaignAsync
     *
     * Get a TollFree SMS Campaign
     *

     * @param  string $campaign_id String that uniquely identifies this TollFree Campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTollFreeSmsCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTollFreeSmsCampaignAsync($campaign_id, string $contentType = self::contentTypes['getTollFreeSmsCampaign'][0])
    {
        return $this->getTollFreeSmsCampaignAsyncWithHttpInfo($campaign_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTollFreeSmsCampaignAsyncWithHttpInfo
     *
     * Get a TollFree SMS Campaign
     *

     * @param  string $campaign_id String that uniquely identifies this TollFree Campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTollFreeSmsCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTollFreeSmsCampaignAsyncWithHttpInfo($campaign_id, string $contentType = self::contentTypes['getTollFreeSmsCampaign'][0])
    {
        $returnType = '\FreeClimb\Api\Model\SMSTollFreeCampaign';
        $request = $this->getTollFreeSmsCampaignRequest($campaign_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTollFreeSmsCampaign'
     *

     * @param  string $campaign_id String that uniquely identifies this TollFree Campaign resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTollFreeSmsCampaign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTollFreeSmsCampaignRequest($campaign_id, string $contentType = self::contentTypes['getTollFreeSmsCampaign'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'campaign_id' is set
        if ($campaign_id === null || (is_array($campaign_id) && count($campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $campaign_id when calling getTollFreeSmsCampaign'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Messages/TollFree/Campaigns/{campaignId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($campaign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'campaignId' . '}',
                ObjectSerializer::toPathValue($campaign_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTollFreeSmsCampaigns
     *
     * Get list of TollFree Campaigns
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTollFreeSmsCampaigns'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\SMSTollFreeCampaignsListResult
     */
    public function getTollFreeSmsCampaigns(string $contentType = self::contentTypes['getTollFreeSmsCampaigns'][0])
    {
        list($response) = $this->getTollFreeSmsCampaignsWithHttpInfo($contentType);
        return $response;
    }     
    /**
     * Operation getTollFreeSmsCampaignsWithHttpInfo
     *
     * Get list of TollFree Campaigns
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTollFreeSmsCampaigns'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\SMSTollFreeCampaignsListResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTollFreeSmsCampaignsWithHttpInfo(string $contentType = self::contentTypes['getTollFreeSmsCampaigns'][0])
    {
        $request = $this->getTollFreeSmsCampaignsRequest($contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\SMSTollFreeCampaignsListResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\SMSTollFreeCampaignsListResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\SMSTollFreeCampaignsListResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\SMSTollFreeCampaignsListResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\SMSTollFreeCampaignsListResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTollFreeSmsCampaignsAsync
     *
     * Get list of TollFree Campaigns
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTollFreeSmsCampaigns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTollFreeSmsCampaignsAsync(string $contentType = self::contentTypes['getTollFreeSmsCampaigns'][0])
    {
        return $this->getTollFreeSmsCampaignsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTollFreeSmsCampaignsAsyncWithHttpInfo
     *
     * Get list of TollFree Campaigns
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTollFreeSmsCampaigns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTollFreeSmsCampaignsAsyncWithHttpInfo(string $contentType = self::contentTypes['getTollFreeSmsCampaigns'][0])
    {
        $returnType = '\FreeClimb\Api\Model\SMSTollFreeCampaignsListResult';
        $request = $this->getTollFreeSmsCampaignsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTollFreeSmsCampaigns'
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTollFreeSmsCampaigns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTollFreeSmsCampaignsRequest(string $contentType = self::contentTypes['getTollFreeSmsCampaigns'][0])
    {
        $account_id = $this->config->getUsername();



        $resourcePath = '/Accounts/{accountId}/Messages/TollFree/Campaigns';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listActiveQueues
     *
     * List Active Queues
     *

     * @param  string $alias Return only the Queue resources with aliases that exactly match this name. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listActiveQueues'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\QueueList
     */
    public function listActiveQueues($alias = null, string $contentType = self::contentTypes['listActiveQueues'][0])
    {
        list($response) = $this->listActiveQueuesWithHttpInfo($alias, $contentType);
        return $response;
    }     
    /**
     * Operation listActiveQueuesWithHttpInfo
     *
     * List Active Queues
     *

     * @param  string $alias Return only the Queue resources with aliases that exactly match this name. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listActiveQueues'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\QueueList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listActiveQueuesWithHttpInfo($alias = null, string $contentType = self::contentTypes['listActiveQueues'][0])
    {
        $request = $this->listActiveQueuesRequest($alias, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\QueueList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\QueueList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\QueueList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\QueueList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\QueueList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listActiveQueuesAsync
     *
     * List Active Queues
     *

     * @param  string $alias Return only the Queue resources with aliases that exactly match this name. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listActiveQueues'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listActiveQueuesAsync($alias = null, string $contentType = self::contentTypes['listActiveQueues'][0])
    {
        return $this->listActiveQueuesAsyncWithHttpInfo($alias, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listActiveQueuesAsyncWithHttpInfo
     *
     * List Active Queues
     *

     * @param  string $alias Return only the Queue resources with aliases that exactly match this name. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listActiveQueues'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listActiveQueuesAsyncWithHttpInfo($alias = null, string $contentType = self::contentTypes['listActiveQueues'][0])
    {
        $returnType = '\FreeClimb\Api\Model\QueueList';
        $request = $this->listActiveQueuesRequest($alias, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listActiveQueues'
     *

     * @param  string $alias Return only the Queue resources with aliases that exactly match this name. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listActiveQueues'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listActiveQueuesRequest($alias = null, string $contentType = self::contentTypes['listActiveQueues'][0])
    {
        $account_id = $this->config->getUsername();




        $resourcePath = '/Accounts/{accountId}/Queues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $alias,
            'alias', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAllAccountLogs
     *
     * List All Account Logs
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAllAccountLogs'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\LogList
     */
    public function listAllAccountLogs(string $contentType = self::contentTypes['listAllAccountLogs'][0])
    {
        list($response) = $this->listAllAccountLogsWithHttpInfo($contentType);
        return $response;
    }     
    /**
     * Operation listAllAccountLogsWithHttpInfo
     *
     * List All Account Logs
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAllAccountLogs'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\LogList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAllAccountLogsWithHttpInfo(string $contentType = self::contentTypes['listAllAccountLogs'][0])
    {
        $request = $this->listAllAccountLogsRequest($contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\LogList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\LogList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\LogList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\LogList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\LogList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAllAccountLogsAsync
     *
     * List All Account Logs
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAllAccountLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAllAccountLogsAsync(string $contentType = self::contentTypes['listAllAccountLogs'][0])
    {
        return $this->listAllAccountLogsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAllAccountLogsAsyncWithHttpInfo
     *
     * List All Account Logs
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAllAccountLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAllAccountLogsAsyncWithHttpInfo(string $contentType = self::contentTypes['listAllAccountLogs'][0])
    {
        $returnType = '\FreeClimb\Api\Model\LogList';
        $request = $this->listAllAccountLogsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAllAccountLogs'
     *

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAllAccountLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listAllAccountLogsRequest(string $contentType = self::contentTypes['listAllAccountLogs'][0])
    {
        $account_id = $this->config->getUsername();



        $resourcePath = '/Accounts/{accountId}/Logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listApplications
     *
     * List applications
     *

     * @param  string $alias Return only applications with aliases that exactly match this value. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listApplications'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\ApplicationList
     */
    public function listApplications($alias = null, string $contentType = self::contentTypes['listApplications'][0])
    {
        list($response) = $this->listApplicationsWithHttpInfo($alias, $contentType);
        return $response;
    }     
    /**
     * Operation listApplicationsWithHttpInfo
     *
     * List applications
     *

     * @param  string $alias Return only applications with aliases that exactly match this value. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listApplications'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\ApplicationList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listApplicationsWithHttpInfo($alias = null, string $contentType = self::contentTypes['listApplications'][0])
    {
        $request = $this->listApplicationsRequest($alias, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\ApplicationList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\ApplicationList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\ApplicationList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\ApplicationList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\ApplicationList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listApplicationsAsync
     *
     * List applications
     *

     * @param  string $alias Return only applications with aliases that exactly match this value. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listApplications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listApplicationsAsync($alias = null, string $contentType = self::contentTypes['listApplications'][0])
    {
        return $this->listApplicationsAsyncWithHttpInfo($alias, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listApplicationsAsyncWithHttpInfo
     *
     * List applications
     *

     * @param  string $alias Return only applications with aliases that exactly match this value. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listApplications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listApplicationsAsyncWithHttpInfo($alias = null, string $contentType = self::contentTypes['listApplications'][0])
    {
        $returnType = '\FreeClimb\Api\Model\ApplicationList';
        $request = $this->listApplicationsRequest($alias, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listApplications'
     *

     * @param  string $alias Return only applications with aliases that exactly match this value. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listApplications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listApplicationsRequest($alias = null, string $contentType = self::contentTypes['listApplications'][0])
    {
        $account_id = $this->config->getUsername();




        $resourcePath = '/Accounts/{accountId}/Applications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $alias,
            'alias', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAvailableNumbers
     *
     * List available numbers
     *

     * @param  string $phone_number PCRE-compatible regular expression to filter against &#x60;phoneNumber&#x60; field, which is in E.164 format. (optional)

     * @param  string $region State or province of this phone number. (optional)

     * @param  string $country Country of this phone number. (optional)

     * @param  bool $voice_enabled Indicates whether the phone number can handle Calls. Typically set to true for all numbers. (optional, default to true)

     * @param  bool $sms_enabled Indication of whether the phone number can handle sending and receiving SMS messages. Typically set to true for all numbers. (optional, default to true)

     * @param  bool $capabilities_voice  (optional)

     * @param  bool $capabilities_sms  (optional)

     * @param  bool $capabilities_toll_free  (optional)

     * @param  bool $capabilities_ten_dlc  (optional)

     * @param  bool $capabilities_short_code  (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAvailableNumbers'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\AvailableNumberList
     */
    public function listAvailableNumbers($phone_number = null, $region = null, $country = null, $voice_enabled = true, $sms_enabled = true, $capabilities_voice = null, $capabilities_sms = null, $capabilities_toll_free = null, $capabilities_ten_dlc = null, $capabilities_short_code = null, string $contentType = self::contentTypes['listAvailableNumbers'][0])
    {
        list($response) = $this->listAvailableNumbersWithHttpInfo($phone_number, $region, $country, $voice_enabled, $sms_enabled, $capabilities_voice, $capabilities_sms, $capabilities_toll_free, $capabilities_ten_dlc, $capabilities_short_code, $contentType);
        return $response;
    }     
    /**
     * Operation listAvailableNumbersWithHttpInfo
     *
     * List available numbers
     *

     * @param  string $phone_number PCRE-compatible regular expression to filter against &#x60;phoneNumber&#x60; field, which is in E.164 format. (optional)

     * @param  string $region State or province of this phone number. (optional)

     * @param  string $country Country of this phone number. (optional)

     * @param  bool $voice_enabled Indicates whether the phone number can handle Calls. Typically set to true for all numbers. (optional, default to true)

     * @param  bool $sms_enabled Indication of whether the phone number can handle sending and receiving SMS messages. Typically set to true for all numbers. (optional, default to true)

     * @param  bool $capabilities_voice  (optional)

     * @param  bool $capabilities_sms  (optional)

     * @param  bool $capabilities_toll_free  (optional)

     * @param  bool $capabilities_ten_dlc  (optional)

     * @param  bool $capabilities_short_code  (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAvailableNumbers'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\AvailableNumberList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAvailableNumbersWithHttpInfo($phone_number = null, $region = null, $country = null, $voice_enabled = true, $sms_enabled = true, $capabilities_voice = null, $capabilities_sms = null, $capabilities_toll_free = null, $capabilities_ten_dlc = null, $capabilities_short_code = null, string $contentType = self::contentTypes['listAvailableNumbers'][0])
    {
        $request = $this->listAvailableNumbersRequest($phone_number, $region, $country, $voice_enabled, $sms_enabled, $capabilities_voice, $capabilities_sms, $capabilities_toll_free, $capabilities_ten_dlc, $capabilities_short_code, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\AvailableNumberList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\AvailableNumberList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\AvailableNumberList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\AvailableNumberList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\AvailableNumberList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAvailableNumbersAsync
     *
     * List available numbers
     *

     * @param  string $phone_number PCRE-compatible regular expression to filter against &#x60;phoneNumber&#x60; field, which is in E.164 format. (optional)

     * @param  string $region State or province of this phone number. (optional)

     * @param  string $country Country of this phone number. (optional)

     * @param  bool $voice_enabled Indicates whether the phone number can handle Calls. Typically set to true for all numbers. (optional, default to true)

     * @param  bool $sms_enabled Indication of whether the phone number can handle sending and receiving SMS messages. Typically set to true for all numbers. (optional, default to true)

     * @param  bool $capabilities_voice  (optional)

     * @param  bool $capabilities_sms  (optional)

     * @param  bool $capabilities_toll_free  (optional)

     * @param  bool $capabilities_ten_dlc  (optional)

     * @param  bool $capabilities_short_code  (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAvailableNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAvailableNumbersAsync($phone_number = null, $region = null, $country = null, $voice_enabled = true, $sms_enabled = true, $capabilities_voice = null, $capabilities_sms = null, $capabilities_toll_free = null, $capabilities_ten_dlc = null, $capabilities_short_code = null, string $contentType = self::contentTypes['listAvailableNumbers'][0])
    {
        return $this->listAvailableNumbersAsyncWithHttpInfo($phone_number, $region, $country, $voice_enabled, $sms_enabled, $capabilities_voice, $capabilities_sms, $capabilities_toll_free, $capabilities_ten_dlc, $capabilities_short_code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAvailableNumbersAsyncWithHttpInfo
     *
     * List available numbers
     *

     * @param  string $phone_number PCRE-compatible regular expression to filter against &#x60;phoneNumber&#x60; field, which is in E.164 format. (optional)

     * @param  string $region State or province of this phone number. (optional)

     * @param  string $country Country of this phone number. (optional)

     * @param  bool $voice_enabled Indicates whether the phone number can handle Calls. Typically set to true for all numbers. (optional, default to true)

     * @param  bool $sms_enabled Indication of whether the phone number can handle sending and receiving SMS messages. Typically set to true for all numbers. (optional, default to true)

     * @param  bool $capabilities_voice  (optional)

     * @param  bool $capabilities_sms  (optional)

     * @param  bool $capabilities_toll_free  (optional)

     * @param  bool $capabilities_ten_dlc  (optional)

     * @param  bool $capabilities_short_code  (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAvailableNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAvailableNumbersAsyncWithHttpInfo($phone_number = null, $region = null, $country = null, $voice_enabled = true, $sms_enabled = true, $capabilities_voice = null, $capabilities_sms = null, $capabilities_toll_free = null, $capabilities_ten_dlc = null, $capabilities_short_code = null, string $contentType = self::contentTypes['listAvailableNumbers'][0])
    {
        $returnType = '\FreeClimb\Api\Model\AvailableNumberList';
        $request = $this->listAvailableNumbersRequest($phone_number, $region, $country, $voice_enabled, $sms_enabled, $capabilities_voice, $capabilities_sms, $capabilities_toll_free, $capabilities_ten_dlc, $capabilities_short_code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAvailableNumbers'
     *

     * @param  string $phone_number PCRE-compatible regular expression to filter against &#x60;phoneNumber&#x60; field, which is in E.164 format. (optional)

     * @param  string $region State or province of this phone number. (optional)

     * @param  string $country Country of this phone number. (optional)

     * @param  bool $voice_enabled Indicates whether the phone number can handle Calls. Typically set to true for all numbers. (optional, default to true)

     * @param  bool $sms_enabled Indication of whether the phone number can handle sending and receiving SMS messages. Typically set to true for all numbers. (optional, default to true)

     * @param  bool $capabilities_voice  (optional)

     * @param  bool $capabilities_sms  (optional)

     * @param  bool $capabilities_toll_free  (optional)

     * @param  bool $capabilities_ten_dlc  (optional)

     * @param  bool $capabilities_short_code  (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAvailableNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listAvailableNumbersRequest($phone_number = null, $region = null, $country = null, $voice_enabled = true, $sms_enabled = true, $capabilities_voice = null, $capabilities_sms = null, $capabilities_toll_free = null, $capabilities_ten_dlc = null, $capabilities_short_code = null, string $contentType = self::contentTypes['listAvailableNumbers'][0])
    {
        $account_id = $this->config->getUsername();













        $resourcePath = '/AvailablePhoneNumbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phone_number,
            'phoneNumber', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region,
            'region', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country,
            'country', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voice_enabled,
            'voiceEnabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sms_enabled,
            'smsEnabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $capabilities_voice,
            'capabilities.voice', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $capabilities_sms,
            'capabilities.sms', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $capabilities_toll_free,
            'capabilities.tollFree', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $capabilities_ten_dlc,
            'capabilities.tenDLC', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $capabilities_short_code,
            'capabilities.shortCode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCallLogs
     *
     * List Call Logs
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCallLogs'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\LogList
     */
    public function listCallLogs($call_id, string $contentType = self::contentTypes['listCallLogs'][0])
    {
        list($response) = $this->listCallLogsWithHttpInfo($call_id, $contentType);
        return $response;
    }     
    /**
     * Operation listCallLogsWithHttpInfo
     *
     * List Call Logs
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCallLogs'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\LogList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCallLogsWithHttpInfo($call_id, string $contentType = self::contentTypes['listCallLogs'][0])
    {
        $request = $this->listCallLogsRequest($call_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\LogList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\LogList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\LogList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\LogList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\LogList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCallLogsAsync
     *
     * List Call Logs
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCallLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCallLogsAsync($call_id, string $contentType = self::contentTypes['listCallLogs'][0])
    {
        return $this->listCallLogsAsyncWithHttpInfo($call_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCallLogsAsyncWithHttpInfo
     *
     * List Call Logs
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCallLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCallLogsAsyncWithHttpInfo($call_id, string $contentType = self::contentTypes['listCallLogs'][0])
    {
        $returnType = '\FreeClimb\Api\Model\LogList';
        $request = $this->listCallLogsRequest($call_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCallLogs'
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCallLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCallLogsRequest($call_id, string $contentType = self::contentTypes['listCallLogs'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling listCallLogs'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Calls/{callId}/Logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCallRecordings
     *
     * List Call Recordings
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $date_created Only show recordings created on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCallRecordings'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\RecordingList
     */
    public function listCallRecordings($call_id, $date_created = null, string $contentType = self::contentTypes['listCallRecordings'][0])
    {
        list($response) = $this->listCallRecordingsWithHttpInfo($call_id, $date_created, $contentType);
        return $response;
    }     
    /**
     * Operation listCallRecordingsWithHttpInfo
     *
     * List Call Recordings
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $date_created Only show recordings created on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCallRecordings'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\RecordingList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCallRecordingsWithHttpInfo($call_id, $date_created = null, string $contentType = self::contentTypes['listCallRecordings'][0])
    {
        $request = $this->listCallRecordingsRequest($call_id, $date_created, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\RecordingList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\RecordingList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\RecordingList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\RecordingList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\RecordingList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCallRecordingsAsync
     *
     * List Call Recordings
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $date_created Only show recordings created on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCallRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCallRecordingsAsync($call_id, $date_created = null, string $contentType = self::contentTypes['listCallRecordings'][0])
    {
        return $this->listCallRecordingsAsyncWithHttpInfo($call_id, $date_created, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCallRecordingsAsyncWithHttpInfo
     *
     * List Call Recordings
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $date_created Only show recordings created on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCallRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCallRecordingsAsyncWithHttpInfo($call_id, $date_created = null, string $contentType = self::contentTypes['listCallRecordings'][0])
    {
        $returnType = '\FreeClimb\Api\Model\RecordingList';
        $request = $this->listCallRecordingsRequest($call_id, $date_created, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCallRecordings'
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  string $date_created Only show recordings created on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCallRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCallRecordingsRequest($call_id, $date_created = null, string $contentType = self::contentTypes['listCallRecordings'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling listCallRecordings'
            );
        }




        $resourcePath = '/Accounts/{accountId}/Calls/{callId}/Recordings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_created,
            'dateCreated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCalls
     *
     * List Calls
     *

     * @param  bool $active If active is set to true then all calls of the nature queued, ringing, inProgress are returned in the query. (optional, default to false)

     * @param  string $to Only show Calls to this phone number. (optional)

     * @param  string $from Only show Calls from this phone number. (optional)

     * @param  \FreeClimb\Api\Model\CallStatus $status Only show Calls currently in this status. May be &#x60;queued&#x60;, &#x60;ringing&#x60;, &#x60;inProgress&#x60;, &#x60;canceled&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;busy&#x60;, or &#x60;noAnswer&#x60;. (optional)

     * @param  string $start_time Only show Calls that started at or after this time, given as YYYY-MM-DD hh:mm:ss. (optional)

     * @param  string $end_time Only show Calls that ended at or before this time, given as YYYY-MM- DD hh:mm:ss. (optional)

     * @param  string $parent_call_id Only show Calls spawned by the call with this ID. (optional)

     * @param  string[] $application_id Only show calls belonging to the given applicationId. This parameter can be repeated to return calls from multiple Applications. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCalls'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\CallList
     */
    public function listCalls($active = false, $to = null, $from = null, $status = null, $start_time = null, $end_time = null, $parent_call_id = null, $application_id = null, string $contentType = self::contentTypes['listCalls'][0])
    {
        list($response) = $this->listCallsWithHttpInfo($active, $to, $from, $status, $start_time, $end_time, $parent_call_id, $application_id, $contentType);
        return $response;
    }     
    /**
     * Operation listCallsWithHttpInfo
     *
     * List Calls
     *

     * @param  bool $active If active is set to true then all calls of the nature queued, ringing, inProgress are returned in the query. (optional, default to false)

     * @param  string $to Only show Calls to this phone number. (optional)

     * @param  string $from Only show Calls from this phone number. (optional)

     * @param  \FreeClimb\Api\Model\CallStatus $status Only show Calls currently in this status. May be &#x60;queued&#x60;, &#x60;ringing&#x60;, &#x60;inProgress&#x60;, &#x60;canceled&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;busy&#x60;, or &#x60;noAnswer&#x60;. (optional)

     * @param  string $start_time Only show Calls that started at or after this time, given as YYYY-MM-DD hh:mm:ss. (optional)

     * @param  string $end_time Only show Calls that ended at or before this time, given as YYYY-MM- DD hh:mm:ss. (optional)

     * @param  string $parent_call_id Only show Calls spawned by the call with this ID. (optional)

     * @param  string[] $application_id Only show calls belonging to the given applicationId. This parameter can be repeated to return calls from multiple Applications. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCalls'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\CallList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCallsWithHttpInfo($active = false, $to = null, $from = null, $status = null, $start_time = null, $end_time = null, $parent_call_id = null, $application_id = null, string $contentType = self::contentTypes['listCalls'][0])
    {
        $request = $this->listCallsRequest($active, $to, $from, $status, $start_time, $end_time, $parent_call_id, $application_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\CallList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\CallList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\CallList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\CallList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\CallList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCallsAsync
     *
     * List Calls
     *

     * @param  bool $active If active is set to true then all calls of the nature queued, ringing, inProgress are returned in the query. (optional, default to false)

     * @param  string $to Only show Calls to this phone number. (optional)

     * @param  string $from Only show Calls from this phone number. (optional)

     * @param  \FreeClimb\Api\Model\CallStatus $status Only show Calls currently in this status. May be &#x60;queued&#x60;, &#x60;ringing&#x60;, &#x60;inProgress&#x60;, &#x60;canceled&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;busy&#x60;, or &#x60;noAnswer&#x60;. (optional)

     * @param  string $start_time Only show Calls that started at or after this time, given as YYYY-MM-DD hh:mm:ss. (optional)

     * @param  string $end_time Only show Calls that ended at or before this time, given as YYYY-MM- DD hh:mm:ss. (optional)

     * @param  string $parent_call_id Only show Calls spawned by the call with this ID. (optional)

     * @param  string[] $application_id Only show calls belonging to the given applicationId. This parameter can be repeated to return calls from multiple Applications. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCalls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCallsAsync($active = false, $to = null, $from = null, $status = null, $start_time = null, $end_time = null, $parent_call_id = null, $application_id = null, string $contentType = self::contentTypes['listCalls'][0])
    {
        return $this->listCallsAsyncWithHttpInfo($active, $to, $from, $status, $start_time, $end_time, $parent_call_id, $application_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCallsAsyncWithHttpInfo
     *
     * List Calls
     *

     * @param  bool $active If active is set to true then all calls of the nature queued, ringing, inProgress are returned in the query. (optional, default to false)

     * @param  string $to Only show Calls to this phone number. (optional)

     * @param  string $from Only show Calls from this phone number. (optional)

     * @param  \FreeClimb\Api\Model\CallStatus $status Only show Calls currently in this status. May be &#x60;queued&#x60;, &#x60;ringing&#x60;, &#x60;inProgress&#x60;, &#x60;canceled&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;busy&#x60;, or &#x60;noAnswer&#x60;. (optional)

     * @param  string $start_time Only show Calls that started at or after this time, given as YYYY-MM-DD hh:mm:ss. (optional)

     * @param  string $end_time Only show Calls that ended at or before this time, given as YYYY-MM- DD hh:mm:ss. (optional)

     * @param  string $parent_call_id Only show Calls spawned by the call with this ID. (optional)

     * @param  string[] $application_id Only show calls belonging to the given applicationId. This parameter can be repeated to return calls from multiple Applications. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCalls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCallsAsyncWithHttpInfo($active = false, $to = null, $from = null, $status = null, $start_time = null, $end_time = null, $parent_call_id = null, $application_id = null, string $contentType = self::contentTypes['listCalls'][0])
    {
        $returnType = '\FreeClimb\Api\Model\CallList';
        $request = $this->listCallsRequest($active, $to, $from, $status, $start_time, $end_time, $parent_call_id, $application_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCalls'
     *

     * @param  bool $active If active is set to true then all calls of the nature queued, ringing, inProgress are returned in the query. (optional, default to false)

     * @param  string $to Only show Calls to this phone number. (optional)

     * @param  string $from Only show Calls from this phone number. (optional)

     * @param  \FreeClimb\Api\Model\CallStatus $status Only show Calls currently in this status. May be &#x60;queued&#x60;, &#x60;ringing&#x60;, &#x60;inProgress&#x60;, &#x60;canceled&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;busy&#x60;, or &#x60;noAnswer&#x60;. (optional)

     * @param  string $start_time Only show Calls that started at or after this time, given as YYYY-MM-DD hh:mm:ss. (optional)

     * @param  string $end_time Only show Calls that ended at or before this time, given as YYYY-MM- DD hh:mm:ss. (optional)

     * @param  string $parent_call_id Only show Calls spawned by the call with this ID. (optional)

     * @param  string[] $application_id Only show calls belonging to the given applicationId. This parameter can be repeated to return calls from multiple Applications. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCalls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCallsRequest($active = false, $to = null, $from = null, $status = null, $start_time = null, $end_time = null, $parent_call_id = null, $application_id = null, string $contentType = self::contentTypes['listCalls'][0])
    {
        $account_id = $this->config->getUsername();








        if ($application_id !== null && count($application_id) > 16) {
            throw new \InvalidArgumentException('invalid value for "$application_id" when calling DefaultApi.listCalls, number of items must be less than or equal to 16.');
        }



        $resourcePath = '/Accounts/{accountId}/Calls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to,
            'to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from,
            'from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'CallStatus', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time,
            'startTime', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time,
            'endTime', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_call_id,
            'parentCallId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $application_id,
            'applicationId', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConferenceRecordings
     *
     * List Conference Recordings
     *

     * @param  string $conference_id Show only Recordings made during the conference with this ID. (required)

     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)

     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConferenceRecordings'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\RecordingList
     */
    public function listConferenceRecordings($conference_id, $call_id = null, $date_created = null, string $contentType = self::contentTypes['listConferenceRecordings'][0])
    {
        list($response) = $this->listConferenceRecordingsWithHttpInfo($conference_id, $call_id, $date_created, $contentType);
        return $response;
    }     
    /**
     * Operation listConferenceRecordingsWithHttpInfo
     *
     * List Conference Recordings
     *

     * @param  string $conference_id Show only Recordings made during the conference with this ID. (required)

     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)

     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConferenceRecordings'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\RecordingList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConferenceRecordingsWithHttpInfo($conference_id, $call_id = null, $date_created = null, string $contentType = self::contentTypes['listConferenceRecordings'][0])
    {
        $request = $this->listConferenceRecordingsRequest($conference_id, $call_id, $date_created, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\RecordingList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\RecordingList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\RecordingList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\RecordingList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\RecordingList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConferenceRecordingsAsync
     *
     * List Conference Recordings
     *

     * @param  string $conference_id Show only Recordings made during the conference with this ID. (required)

     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)

     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConferenceRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConferenceRecordingsAsync($conference_id, $call_id = null, $date_created = null, string $contentType = self::contentTypes['listConferenceRecordings'][0])
    {
        return $this->listConferenceRecordingsAsyncWithHttpInfo($conference_id, $call_id, $date_created, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConferenceRecordingsAsyncWithHttpInfo
     *
     * List Conference Recordings
     *

     * @param  string $conference_id Show only Recordings made during the conference with this ID. (required)

     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)

     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConferenceRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConferenceRecordingsAsyncWithHttpInfo($conference_id, $call_id = null, $date_created = null, string $contentType = self::contentTypes['listConferenceRecordings'][0])
    {
        $returnType = '\FreeClimb\Api\Model\RecordingList';
        $request = $this->listConferenceRecordingsRequest($conference_id, $call_id, $date_created, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConferenceRecordings'
     *

     * @param  string $conference_id Show only Recordings made during the conference with this ID. (required)

     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)

     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConferenceRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConferenceRecordingsRequest($conference_id, $call_id = null, $date_created = null, string $contentType = self::contentTypes['listConferenceRecordings'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'conference_id' is set
        if ($conference_id === null || (is_array($conference_id) && count($conference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_id when calling listConferenceRecordings'
            );
        }





        $resourcePath = '/Accounts/{accountId}/Conferences/{conferenceId}/Recordings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $call_id,
            'callId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_created,
            'dateCreated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($conference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'conferenceId' . '}',
                ObjectSerializer::toPathValue($conference_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConferences
     *
     * List Conferences
     *

     * @param  string $status Only show conferences that currently have the specified status. Valid values: &#x60;empty&#x60;, &#x60;populated&#x60;, &#x60;inProgress&#x60;, or &#x60;terminated&#x60;. (optional)

     * @param  string $alias List Conferences whose alias exactly matches this string. (optional)

     * @param  string $date_created Only show Conferences that were created on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $date_updated Only show Conferences that were last updated on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConferences'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\ConferenceList
     */
    public function listConferences($status = null, $alias = null, $date_created = null, $date_updated = null, string $contentType = self::contentTypes['listConferences'][0])
    {
        list($response) = $this->listConferencesWithHttpInfo($status, $alias, $date_created, $date_updated, $contentType);
        return $response;
    }     
    /**
     * Operation listConferencesWithHttpInfo
     *
     * List Conferences
     *

     * @param  string $status Only show conferences that currently have the specified status. Valid values: &#x60;empty&#x60;, &#x60;populated&#x60;, &#x60;inProgress&#x60;, or &#x60;terminated&#x60;. (optional)

     * @param  string $alias List Conferences whose alias exactly matches this string. (optional)

     * @param  string $date_created Only show Conferences that were created on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $date_updated Only show Conferences that were last updated on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConferences'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\ConferenceList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConferencesWithHttpInfo($status = null, $alias = null, $date_created = null, $date_updated = null, string $contentType = self::contentTypes['listConferences'][0])
    {
        $request = $this->listConferencesRequest($status, $alias, $date_created, $date_updated, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\ConferenceList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\ConferenceList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\ConferenceList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\ConferenceList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\ConferenceList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConferencesAsync
     *
     * List Conferences
     *

     * @param  string $status Only show conferences that currently have the specified status. Valid values: &#x60;empty&#x60;, &#x60;populated&#x60;, &#x60;inProgress&#x60;, or &#x60;terminated&#x60;. (optional)

     * @param  string $alias List Conferences whose alias exactly matches this string. (optional)

     * @param  string $date_created Only show Conferences that were created on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $date_updated Only show Conferences that were last updated on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConferences'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConferencesAsync($status = null, $alias = null, $date_created = null, $date_updated = null, string $contentType = self::contentTypes['listConferences'][0])
    {
        return $this->listConferencesAsyncWithHttpInfo($status, $alias, $date_created, $date_updated, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConferencesAsyncWithHttpInfo
     *
     * List Conferences
     *

     * @param  string $status Only show conferences that currently have the specified status. Valid values: &#x60;empty&#x60;, &#x60;populated&#x60;, &#x60;inProgress&#x60;, or &#x60;terminated&#x60;. (optional)

     * @param  string $alias List Conferences whose alias exactly matches this string. (optional)

     * @param  string $date_created Only show Conferences that were created on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $date_updated Only show Conferences that were last updated on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConferences'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConferencesAsyncWithHttpInfo($status = null, $alias = null, $date_created = null, $date_updated = null, string $contentType = self::contentTypes['listConferences'][0])
    {
        $returnType = '\FreeClimb\Api\Model\ConferenceList';
        $request = $this->listConferencesRequest($status, $alias, $date_created, $date_updated, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConferences'
     *

     * @param  string $status Only show conferences that currently have the specified status. Valid values: &#x60;empty&#x60;, &#x60;populated&#x60;, &#x60;inProgress&#x60;, or &#x60;terminated&#x60;. (optional)

     * @param  string $alias List Conferences whose alias exactly matches this string. (optional)

     * @param  string $date_created Only show Conferences that were created on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $date_updated Only show Conferences that were last updated on the specified date, in the form *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConferences'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConferencesRequest($status = null, $alias = null, $date_created = null, $date_updated = null, string $contentType = self::contentTypes['listConferences'][0])
    {
        $account_id = $this->config->getUsername();







        $resourcePath = '/Accounts/{accountId}/Conferences';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $alias,
            'alias', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_created,
            'dateCreated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_updated,
            'dateUpdated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listIncomingNumbers
     *
     * List Incoming Numbers
     *

     * @param  string $phone_number Only show incoming phone number resources that match this PCRE-compatible regular expression. (optional)

     * @param  string $alias Only show incoming phone numbers with aliases that exactly match this value. (optional)

     * @param  string $region State or province of this phone number. (optional)

     * @param  string $country Country of this phone number. (optional)

     * @param  string $application_id ID of the Application that FreeClimb should contact if a Call or SMS arrives for this phone number or a Call from this number is placed. An incoming phone number is not useful until associated with an applicationId. (optional)

     * @param  bool $has_application Indication of whether the phone number has an application linked to it. (optional, default to false)

     * @param  bool $voice_enabled Indicates whether the phone number can handle Calls. Typically set to true for all numbers. (optional, default to true) (deprecated)

     * @param  bool $sms_enabled Indication of whether the phone number can handle sending and receiving SMS messages. Typically set to true for all numbers. (optional, default to true) (deprecated)

     * @param  bool $has_campaign Indication of whether the phone number has a campaign associated with it (optional)

     * @param  bool $capabilities_voice  (optional)

     * @param  bool $capabilities_sms  (optional)

     * @param  bool $capabilities_toll_free  (optional)

     * @param  bool $capabilities_ten_dlc  (optional)

     * @param  bool $capabilities_short_code  (optional)

     * @param  string $tfn_campaign_id Only show incoming phone number resources that have been assigned to the provided TFNCampaign ID. (optional)

     * @param  bool $offnet Indication of whether the phone number was registered as an offnet number. This field will be rendered only for requests to the IncomingPhone number resource. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIncomingNumbers'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\IncomingNumberList
     */
    public function listIncomingNumbers($phone_number = null, $alias = null, $region = null, $country = null, $application_id = null, $has_application = false, $voice_enabled = true, $sms_enabled = true, $has_campaign = null, $capabilities_voice = null, $capabilities_sms = null, $capabilities_toll_free = null, $capabilities_ten_dlc = null, $capabilities_short_code = null, $tfn_campaign_id = null, $offnet = null, string $contentType = self::contentTypes['listIncomingNumbers'][0])
    {
        list($response) = $this->listIncomingNumbersWithHttpInfo($phone_number, $alias, $region, $country, $application_id, $has_application, $voice_enabled, $sms_enabled, $has_campaign, $capabilities_voice, $capabilities_sms, $capabilities_toll_free, $capabilities_ten_dlc, $capabilities_short_code, $tfn_campaign_id, $offnet, $contentType);
        return $response;
    }     
    /**
     * Operation listIncomingNumbersWithHttpInfo
     *
     * List Incoming Numbers
     *

     * @param  string $phone_number Only show incoming phone number resources that match this PCRE-compatible regular expression. (optional)

     * @param  string $alias Only show incoming phone numbers with aliases that exactly match this value. (optional)

     * @param  string $region State or province of this phone number. (optional)

     * @param  string $country Country of this phone number. (optional)

     * @param  string $application_id ID of the Application that FreeClimb should contact if a Call or SMS arrives for this phone number or a Call from this number is placed. An incoming phone number is not useful until associated with an applicationId. (optional)

     * @param  bool $has_application Indication of whether the phone number has an application linked to it. (optional, default to false)

     * @param  bool $voice_enabled Indicates whether the phone number can handle Calls. Typically set to true for all numbers. (optional, default to true) (deprecated)

     * @param  bool $sms_enabled Indication of whether the phone number can handle sending and receiving SMS messages. Typically set to true for all numbers. (optional, default to true) (deprecated)

     * @param  bool $has_campaign Indication of whether the phone number has a campaign associated with it (optional)

     * @param  bool $capabilities_voice  (optional)

     * @param  bool $capabilities_sms  (optional)

     * @param  bool $capabilities_toll_free  (optional)

     * @param  bool $capabilities_ten_dlc  (optional)

     * @param  bool $capabilities_short_code  (optional)

     * @param  string $tfn_campaign_id Only show incoming phone number resources that have been assigned to the provided TFNCampaign ID. (optional)

     * @param  bool $offnet Indication of whether the phone number was registered as an offnet number. This field will be rendered only for requests to the IncomingPhone number resource. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIncomingNumbers'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\IncomingNumberList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listIncomingNumbersWithHttpInfo($phone_number = null, $alias = null, $region = null, $country = null, $application_id = null, $has_application = false, $voice_enabled = true, $sms_enabled = true, $has_campaign = null, $capabilities_voice = null, $capabilities_sms = null, $capabilities_toll_free = null, $capabilities_ten_dlc = null, $capabilities_short_code = null, $tfn_campaign_id = null, $offnet = null, string $contentType = self::contentTypes['listIncomingNumbers'][0])
    {
        $request = $this->listIncomingNumbersRequest($phone_number, $alias, $region, $country, $application_id, $has_application, $voice_enabled, $sms_enabled, $has_campaign, $capabilities_voice, $capabilities_sms, $capabilities_toll_free, $capabilities_ten_dlc, $capabilities_short_code, $tfn_campaign_id, $offnet, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\IncomingNumberList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\IncomingNumberList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\IncomingNumberList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\IncomingNumberList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\IncomingNumberList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listIncomingNumbersAsync
     *
     * List Incoming Numbers
     *

     * @param  string $phone_number Only show incoming phone number resources that match this PCRE-compatible regular expression. (optional)

     * @param  string $alias Only show incoming phone numbers with aliases that exactly match this value. (optional)

     * @param  string $region State or province of this phone number. (optional)

     * @param  string $country Country of this phone number. (optional)

     * @param  string $application_id ID of the Application that FreeClimb should contact if a Call or SMS arrives for this phone number or a Call from this number is placed. An incoming phone number is not useful until associated with an applicationId. (optional)

     * @param  bool $has_application Indication of whether the phone number has an application linked to it. (optional, default to false)

     * @param  bool $voice_enabled Indicates whether the phone number can handle Calls. Typically set to true for all numbers. (optional, default to true) (deprecated)

     * @param  bool $sms_enabled Indication of whether the phone number can handle sending and receiving SMS messages. Typically set to true for all numbers. (optional, default to true) (deprecated)

     * @param  bool $has_campaign Indication of whether the phone number has a campaign associated with it (optional)

     * @param  bool $capabilities_voice  (optional)

     * @param  bool $capabilities_sms  (optional)

     * @param  bool $capabilities_toll_free  (optional)

     * @param  bool $capabilities_ten_dlc  (optional)

     * @param  bool $capabilities_short_code  (optional)

     * @param  string $tfn_campaign_id Only show incoming phone number resources that have been assigned to the provided TFNCampaign ID. (optional)

     * @param  bool $offnet Indication of whether the phone number was registered as an offnet number. This field will be rendered only for requests to the IncomingPhone number resource. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIncomingNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listIncomingNumbersAsync($phone_number = null, $alias = null, $region = null, $country = null, $application_id = null, $has_application = false, $voice_enabled = true, $sms_enabled = true, $has_campaign = null, $capabilities_voice = null, $capabilities_sms = null, $capabilities_toll_free = null, $capabilities_ten_dlc = null, $capabilities_short_code = null, $tfn_campaign_id = null, $offnet = null, string $contentType = self::contentTypes['listIncomingNumbers'][0])
    {
        return $this->listIncomingNumbersAsyncWithHttpInfo($phone_number, $alias, $region, $country, $application_id, $has_application, $voice_enabled, $sms_enabled, $has_campaign, $capabilities_voice, $capabilities_sms, $capabilities_toll_free, $capabilities_ten_dlc, $capabilities_short_code, $tfn_campaign_id, $offnet, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listIncomingNumbersAsyncWithHttpInfo
     *
     * List Incoming Numbers
     *

     * @param  string $phone_number Only show incoming phone number resources that match this PCRE-compatible regular expression. (optional)

     * @param  string $alias Only show incoming phone numbers with aliases that exactly match this value. (optional)

     * @param  string $region State or province of this phone number. (optional)

     * @param  string $country Country of this phone number. (optional)

     * @param  string $application_id ID of the Application that FreeClimb should contact if a Call or SMS arrives for this phone number or a Call from this number is placed. An incoming phone number is not useful until associated with an applicationId. (optional)

     * @param  bool $has_application Indication of whether the phone number has an application linked to it. (optional, default to false)

     * @param  bool $voice_enabled Indicates whether the phone number can handle Calls. Typically set to true for all numbers. (optional, default to true) (deprecated)

     * @param  bool $sms_enabled Indication of whether the phone number can handle sending and receiving SMS messages. Typically set to true for all numbers. (optional, default to true) (deprecated)

     * @param  bool $has_campaign Indication of whether the phone number has a campaign associated with it (optional)

     * @param  bool $capabilities_voice  (optional)

     * @param  bool $capabilities_sms  (optional)

     * @param  bool $capabilities_toll_free  (optional)

     * @param  bool $capabilities_ten_dlc  (optional)

     * @param  bool $capabilities_short_code  (optional)

     * @param  string $tfn_campaign_id Only show incoming phone number resources that have been assigned to the provided TFNCampaign ID. (optional)

     * @param  bool $offnet Indication of whether the phone number was registered as an offnet number. This field will be rendered only for requests to the IncomingPhone number resource. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIncomingNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listIncomingNumbersAsyncWithHttpInfo($phone_number = null, $alias = null, $region = null, $country = null, $application_id = null, $has_application = false, $voice_enabled = true, $sms_enabled = true, $has_campaign = null, $capabilities_voice = null, $capabilities_sms = null, $capabilities_toll_free = null, $capabilities_ten_dlc = null, $capabilities_short_code = null, $tfn_campaign_id = null, $offnet = null, string $contentType = self::contentTypes['listIncomingNumbers'][0])
    {
        $returnType = '\FreeClimb\Api\Model\IncomingNumberList';
        $request = $this->listIncomingNumbersRequest($phone_number, $alias, $region, $country, $application_id, $has_application, $voice_enabled, $sms_enabled, $has_campaign, $capabilities_voice, $capabilities_sms, $capabilities_toll_free, $capabilities_ten_dlc, $capabilities_short_code, $tfn_campaign_id, $offnet, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listIncomingNumbers'
     *

     * @param  string $phone_number Only show incoming phone number resources that match this PCRE-compatible regular expression. (optional)

     * @param  string $alias Only show incoming phone numbers with aliases that exactly match this value. (optional)

     * @param  string $region State or province of this phone number. (optional)

     * @param  string $country Country of this phone number. (optional)

     * @param  string $application_id ID of the Application that FreeClimb should contact if a Call or SMS arrives for this phone number or a Call from this number is placed. An incoming phone number is not useful until associated with an applicationId. (optional)

     * @param  bool $has_application Indication of whether the phone number has an application linked to it. (optional, default to false)

     * @param  bool $voice_enabled Indicates whether the phone number can handle Calls. Typically set to true for all numbers. (optional, default to true) (deprecated)

     * @param  bool $sms_enabled Indication of whether the phone number can handle sending and receiving SMS messages. Typically set to true for all numbers. (optional, default to true) (deprecated)

     * @param  bool $has_campaign Indication of whether the phone number has a campaign associated with it (optional)

     * @param  bool $capabilities_voice  (optional)

     * @param  bool $capabilities_sms  (optional)

     * @param  bool $capabilities_toll_free  (optional)

     * @param  bool $capabilities_ten_dlc  (optional)

     * @param  bool $capabilities_short_code  (optional)

     * @param  string $tfn_campaign_id Only show incoming phone number resources that have been assigned to the provided TFNCampaign ID. (optional)

     * @param  bool $offnet Indication of whether the phone number was registered as an offnet number. This field will be rendered only for requests to the IncomingPhone number resource. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIncomingNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listIncomingNumbersRequest($phone_number = null, $alias = null, $region = null, $country = null, $application_id = null, $has_application = false, $voice_enabled = true, $sms_enabled = true, $has_campaign = null, $capabilities_voice = null, $capabilities_sms = null, $capabilities_toll_free = null, $capabilities_ten_dlc = null, $capabilities_short_code = null, $tfn_campaign_id = null, $offnet = null, string $contentType = self::contentTypes['listIncomingNumbers'][0])
    {
        $account_id = $this->config->getUsername();



















        $resourcePath = '/Accounts/{accountId}/IncomingPhoneNumbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phone_number,
            'phoneNumber', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $alias,
            'alias', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $region,
            'region', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country,
            'country', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $application_id,
            'applicationId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $has_application,
            'hasApplication', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voice_enabled,
            'voiceEnabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sms_enabled,
            'smsEnabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $has_campaign,
            'hasCampaign', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $capabilities_voice,
            'capabilities.voice', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $capabilities_sms,
            'capabilities.sms', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $capabilities_toll_free,
            'capabilities.tollFree', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $capabilities_ten_dlc,
            'capabilities.tenDLC', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $capabilities_short_code,
            'capabilities.shortCode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tfn_campaign_id,
            'tfn.campaignId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offnet,
            'offnet', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMembers
     *
     * List Members
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\QueueMemberList
     */
    public function listMembers($queue_id, string $contentType = self::contentTypes['listMembers'][0])
    {
        list($response) = $this->listMembersWithHttpInfo($queue_id, $contentType);
        return $response;
    }     
    /**
     * Operation listMembersWithHttpInfo
     *
     * List Members
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\QueueMemberList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMembersWithHttpInfo($queue_id, string $contentType = self::contentTypes['listMembers'][0])
    {
        $request = $this->listMembersRequest($queue_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\QueueMemberList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\QueueMemberList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\QueueMemberList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\QueueMemberList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\QueueMemberList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listMembersAsync
     *
     * List Members
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMembersAsync($queue_id, string $contentType = self::contentTypes['listMembers'][0])
    {
        return $this->listMembersAsyncWithHttpInfo($queue_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMembersAsyncWithHttpInfo
     *
     * List Members
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMembersAsyncWithHttpInfo($queue_id, string $contentType = self::contentTypes['listMembers'][0])
    {
        $returnType = '\FreeClimb\Api\Model\QueueMemberList';
        $request = $this->listMembersRequest($queue_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMembers'
     *

     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMembersRequest($queue_id, string $contentType = self::contentTypes['listMembers'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'queue_id' is set
        if ($queue_id === null || (is_array($queue_id) && count($queue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_id when calling listMembers'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Queues/{queueId}/Members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($queue_id !== null) {
            $resourcePath = str_replace(
                '{' . 'queueId' . '}',
                ObjectSerializer::toPathValue($queue_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listParticipants
     *
     * List Participants
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  bool $talk Only show Participants with the talk privilege. (optional)

     * @param  bool $listen Only show Participants with the listen privilege. (optional)

     * @param  bool $dtmf_pass_through Only show Participants with the dtmfPassThrough privilege. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listParticipants'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\ConferenceParticipantList
     */
    public function listParticipants($conference_id, $talk = null, $listen = null, $dtmf_pass_through = null, string $contentType = self::contentTypes['listParticipants'][0])
    {
        list($response) = $this->listParticipantsWithHttpInfo($conference_id, $talk, $listen, $dtmf_pass_through, $contentType);
        return $response;
    }     
    /**
     * Operation listParticipantsWithHttpInfo
     *
     * List Participants
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  bool $talk Only show Participants with the talk privilege. (optional)

     * @param  bool $listen Only show Participants with the listen privilege. (optional)

     * @param  bool $dtmf_pass_through Only show Participants with the dtmfPassThrough privilege. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listParticipants'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\ConferenceParticipantList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listParticipantsWithHttpInfo($conference_id, $talk = null, $listen = null, $dtmf_pass_through = null, string $contentType = self::contentTypes['listParticipants'][0])
    {
        $request = $this->listParticipantsRequest($conference_id, $talk, $listen, $dtmf_pass_through, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\ConferenceParticipantList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\ConferenceParticipantList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\ConferenceParticipantList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\ConferenceParticipantList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\ConferenceParticipantList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listParticipantsAsync
     *
     * List Participants
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  bool $talk Only show Participants with the talk privilege. (optional)

     * @param  bool $listen Only show Participants with the listen privilege. (optional)

     * @param  bool $dtmf_pass_through Only show Participants with the dtmfPassThrough privilege. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listParticipants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listParticipantsAsync($conference_id, $talk = null, $listen = null, $dtmf_pass_through = null, string $contentType = self::contentTypes['listParticipants'][0])
    {
        return $this->listParticipantsAsyncWithHttpInfo($conference_id, $talk, $listen, $dtmf_pass_through, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listParticipantsAsyncWithHttpInfo
     *
     * List Participants
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  bool $talk Only show Participants with the talk privilege. (optional)

     * @param  bool $listen Only show Participants with the listen privilege. (optional)

     * @param  bool $dtmf_pass_through Only show Participants with the dtmfPassThrough privilege. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listParticipants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listParticipantsAsyncWithHttpInfo($conference_id, $talk = null, $listen = null, $dtmf_pass_through = null, string $contentType = self::contentTypes['listParticipants'][0])
    {
        $returnType = '\FreeClimb\Api\Model\ConferenceParticipantList';
        $request = $this->listParticipantsRequest($conference_id, $talk, $listen, $dtmf_pass_through, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listParticipants'
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  bool $talk Only show Participants with the talk privilege. (optional)

     * @param  bool $listen Only show Participants with the listen privilege. (optional)

     * @param  bool $dtmf_pass_through Only show Participants with the dtmfPassThrough privilege. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listParticipants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listParticipantsRequest($conference_id, $talk = null, $listen = null, $dtmf_pass_through = null, string $contentType = self::contentTypes['listParticipants'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'conference_id' is set
        if ($conference_id === null || (is_array($conference_id) && count($conference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_id when calling listParticipants'
            );
        }






        $resourcePath = '/Accounts/{accountId}/Conferences/{conferenceId}/Participants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $talk,
            'talk', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listen,
            'listen', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dtmf_pass_through,
            'dtmfPassThrough', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($conference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'conferenceId' . '}',
                ObjectSerializer::toPathValue($conference_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listRecordings
     *
     * List Recordings
     *

     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)

     * @param  string $conference_id Show only Recordings made during the conference with this ID. (optional)

     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRecordings'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\RecordingList
     */
    public function listRecordings($call_id = null, $conference_id = null, $date_created = null, string $contentType = self::contentTypes['listRecordings'][0])
    {
        list($response) = $this->listRecordingsWithHttpInfo($call_id, $conference_id, $date_created, $contentType);
        return $response;
    }     
    /**
     * Operation listRecordingsWithHttpInfo
     *
     * List Recordings
     *

     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)

     * @param  string $conference_id Show only Recordings made during the conference with this ID. (optional)

     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRecordings'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\RecordingList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listRecordingsWithHttpInfo($call_id = null, $conference_id = null, $date_created = null, string $contentType = self::contentTypes['listRecordings'][0])
    {
        $request = $this->listRecordingsRequest($call_id, $conference_id, $date_created, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\RecordingList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\RecordingList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\RecordingList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\RecordingList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\RecordingList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listRecordingsAsync
     *
     * List Recordings
     *

     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)

     * @param  string $conference_id Show only Recordings made during the conference with this ID. (optional)

     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRecordingsAsync($call_id = null, $conference_id = null, $date_created = null, string $contentType = self::contentTypes['listRecordings'][0])
    {
        return $this->listRecordingsAsyncWithHttpInfo($call_id, $conference_id, $date_created, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listRecordingsAsyncWithHttpInfo
     *
     * List Recordings
     *

     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)

     * @param  string $conference_id Show only Recordings made during the conference with this ID. (optional)

     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRecordingsAsyncWithHttpInfo($call_id = null, $conference_id = null, $date_created = null, string $contentType = self::contentTypes['listRecordings'][0])
    {
        $returnType = '\FreeClimb\Api\Model\RecordingList';
        $request = $this->listRecordingsRequest($call_id, $conference_id, $date_created, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listRecordings'
     *

     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)

     * @param  string $conference_id Show only Recordings made during the conference with this ID. (optional)

     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listRecordingsRequest($call_id = null, $conference_id = null, $date_created = null, string $contentType = self::contentTypes['listRecordings'][0])
    {
        $account_id = $this->config->getUsername();






        $resourcePath = '/Accounts/{accountId}/Recordings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $call_id,
            'callId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $conference_id,
            'conferenceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_created,
            'dateCreated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listSmsMessages
     *
     * List SMS Messages
     *

     * @param  string $to Only show Messages to this phone number. (optional)

     * @param  string $from Only show Messages from this phone number. (optional)

     * @param  string $begin_time Only show Messages sent at or after this time (GMT), given as *YYYY-MM-DD hh:mm:ss*. (optional)

     * @param  string $end_time Only show messages sent at or before this time (GMT), given as *YYYY-MM-DD hh:mm*.. (optional)

     * @param  \FreeClimb\Api\Model\MessageDirection $direction Either &#x60;inbound&#x60; or &#x60;outbound&#x60;. Only show Messages that were either *sent from* or *received by* FreeClimb. (optional)

     * @param  string $campaign_id Only show messages associated with this campaign ID. (optional)

     * @param  string $brand_id Only show messages associated with this brand ID (optional)

     * @param  bool $is10_dlc Only show messages that were sent as part of a 10DLC campaign. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSmsMessages'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\MessagesList
     */
    public function listSmsMessages($to = null, $from = null, $begin_time = null, $end_time = null, $direction = null, $campaign_id = null, $brand_id = null, $is10_dlc = null, string $contentType = self::contentTypes['listSmsMessages'][0])
    {
        list($response) = $this->listSmsMessagesWithHttpInfo($to, $from, $begin_time, $end_time, $direction, $campaign_id, $brand_id, $is10_dlc, $contentType);
        return $response;
    }     
    /**
     * Operation listSmsMessagesWithHttpInfo
     *
     * List SMS Messages
     *

     * @param  string $to Only show Messages to this phone number. (optional)

     * @param  string $from Only show Messages from this phone number. (optional)

     * @param  string $begin_time Only show Messages sent at or after this time (GMT), given as *YYYY-MM-DD hh:mm:ss*. (optional)

     * @param  string $end_time Only show messages sent at or before this time (GMT), given as *YYYY-MM-DD hh:mm*.. (optional)

     * @param  \FreeClimb\Api\Model\MessageDirection $direction Either &#x60;inbound&#x60; or &#x60;outbound&#x60;. Only show Messages that were either *sent from* or *received by* FreeClimb. (optional)

     * @param  string $campaign_id Only show messages associated with this campaign ID. (optional)

     * @param  string $brand_id Only show messages associated with this brand ID (optional)

     * @param  bool $is10_dlc Only show messages that were sent as part of a 10DLC campaign. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSmsMessages'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\MessagesList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listSmsMessagesWithHttpInfo($to = null, $from = null, $begin_time = null, $end_time = null, $direction = null, $campaign_id = null, $brand_id = null, $is10_dlc = null, string $contentType = self::contentTypes['listSmsMessages'][0])
    {
        $request = $this->listSmsMessagesRequest($to, $from, $begin_time, $end_time, $direction, $campaign_id, $brand_id, $is10_dlc, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\MessagesList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\MessagesList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\MessagesList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\MessagesList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\MessagesList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listSmsMessagesAsync
     *
     * List SMS Messages
     *

     * @param  string $to Only show Messages to this phone number. (optional)

     * @param  string $from Only show Messages from this phone number. (optional)

     * @param  string $begin_time Only show Messages sent at or after this time (GMT), given as *YYYY-MM-DD hh:mm:ss*. (optional)

     * @param  string $end_time Only show messages sent at or before this time (GMT), given as *YYYY-MM-DD hh:mm*.. (optional)

     * @param  \FreeClimb\Api\Model\MessageDirection $direction Either &#x60;inbound&#x60; or &#x60;outbound&#x60;. Only show Messages that were either *sent from* or *received by* FreeClimb. (optional)

     * @param  string $campaign_id Only show messages associated with this campaign ID. (optional)

     * @param  string $brand_id Only show messages associated with this brand ID (optional)

     * @param  bool $is10_dlc Only show messages that were sent as part of a 10DLC campaign. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSmsMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSmsMessagesAsync($to = null, $from = null, $begin_time = null, $end_time = null, $direction = null, $campaign_id = null, $brand_id = null, $is10_dlc = null, string $contentType = self::contentTypes['listSmsMessages'][0])
    {
        return $this->listSmsMessagesAsyncWithHttpInfo($to, $from, $begin_time, $end_time, $direction, $campaign_id, $brand_id, $is10_dlc, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listSmsMessagesAsyncWithHttpInfo
     *
     * List SMS Messages
     *

     * @param  string $to Only show Messages to this phone number. (optional)

     * @param  string $from Only show Messages from this phone number. (optional)

     * @param  string $begin_time Only show Messages sent at or after this time (GMT), given as *YYYY-MM-DD hh:mm:ss*. (optional)

     * @param  string $end_time Only show messages sent at or before this time (GMT), given as *YYYY-MM-DD hh:mm*.. (optional)

     * @param  \FreeClimb\Api\Model\MessageDirection $direction Either &#x60;inbound&#x60; or &#x60;outbound&#x60;. Only show Messages that were either *sent from* or *received by* FreeClimb. (optional)

     * @param  string $campaign_id Only show messages associated with this campaign ID. (optional)

     * @param  string $brand_id Only show messages associated with this brand ID (optional)

     * @param  bool $is10_dlc Only show messages that were sent as part of a 10DLC campaign. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSmsMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSmsMessagesAsyncWithHttpInfo($to = null, $from = null, $begin_time = null, $end_time = null, $direction = null, $campaign_id = null, $brand_id = null, $is10_dlc = null, string $contentType = self::contentTypes['listSmsMessages'][0])
    {
        $returnType = '\FreeClimb\Api\Model\MessagesList';
        $request = $this->listSmsMessagesRequest($to, $from, $begin_time, $end_time, $direction, $campaign_id, $brand_id, $is10_dlc, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listSmsMessages'
     *

     * @param  string $to Only show Messages to this phone number. (optional)

     * @param  string $from Only show Messages from this phone number. (optional)

     * @param  string $begin_time Only show Messages sent at or after this time (GMT), given as *YYYY-MM-DD hh:mm:ss*. (optional)

     * @param  string $end_time Only show messages sent at or before this time (GMT), given as *YYYY-MM-DD hh:mm*.. (optional)

     * @param  \FreeClimb\Api\Model\MessageDirection $direction Either &#x60;inbound&#x60; or &#x60;outbound&#x60;. Only show Messages that were either *sent from* or *received by* FreeClimb. (optional)

     * @param  string $campaign_id Only show messages associated with this campaign ID. (optional)

     * @param  string $brand_id Only show messages associated with this brand ID (optional)

     * @param  bool $is10_dlc Only show messages that were sent as part of a 10DLC campaign. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSmsMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listSmsMessagesRequest($to = null, $from = null, $begin_time = null, $end_time = null, $direction = null, $campaign_id = null, $brand_id = null, $is10_dlc = null, string $contentType = self::contentTypes['listSmsMessages'][0])
    {
        $account_id = $this->config->getUsername();











        $resourcePath = '/Accounts/{accountId}/Messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to,
            'to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from,
            'from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $begin_time,
            'beginTime', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time,
            'endTime', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'MessageDirection', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $campaign_id,
            'campaignId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brand_id,
            'brandId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is10_dlc,
            'is10DLC', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation makeACall
     *
     * Make a Call
     *

     * @param  \FreeClimb\Api\Model\MakeCallRequest $make_call_request Call details for making a call (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['makeACall'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\CallResult
     */
    public function makeACall($make_call_request = null, string $contentType = self::contentTypes['makeACall'][0])
    {
        list($response) = $this->makeACallWithHttpInfo($make_call_request, $contentType);
        return $response;
    }     
    /**
     * Operation makeACallWithHttpInfo
     *
     * Make a Call
     *

     * @param  \FreeClimb\Api\Model\MakeCallRequest $make_call_request Call details for making a call (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['makeACall'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\CallResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function makeACallWithHttpInfo($make_call_request = null, string $contentType = self::contentTypes['makeACall'][0])
    {
        $request = $this->makeACallRequest($make_call_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\CallResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\CallResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\CallResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\CallResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\CallResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation makeACallAsync
     *
     * Make a Call
     *

     * @param  \FreeClimb\Api\Model\MakeCallRequest $make_call_request Call details for making a call (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['makeACall'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function makeACallAsync($make_call_request = null, string $contentType = self::contentTypes['makeACall'][0])
    {
        return $this->makeACallAsyncWithHttpInfo($make_call_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation makeACallAsyncWithHttpInfo
     *
     * Make a Call
     *

     * @param  \FreeClimb\Api\Model\MakeCallRequest $make_call_request Call details for making a call (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['makeACall'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function makeACallAsyncWithHttpInfo($make_call_request = null, string $contentType = self::contentTypes['makeACall'][0])
    {
        $returnType = '\FreeClimb\Api\Model\CallResult';
        $request = $this->makeACallRequest($make_call_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'makeACall'
     *

     * @param  \FreeClimb\Api\Model\MakeCallRequest $make_call_request Call details for making a call (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['makeACall'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function makeACallRequest($make_call_request = null, string $contentType = self::contentTypes['makeACall'][0])
    {
        $account_id = $this->config->getUsername();




        $resourcePath = '/Accounts/{accountId}/Calls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($make_call_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($make_call_request));
            } else {
                $httpBody = $make_call_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation makeAWebrtcJwt
     *
     * Make a JWT for WebRTC calling
     *

     * @param  \FreeClimb\Api\Model\CreateWebRTCToken $create_web_rtc_token Information needed to craft a JWT compatible with the platforms WebRTC APIs (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['makeAWebrtcJwt'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function makeAWebrtcJwt($create_web_rtc_token, string $contentType = self::contentTypes['makeAWebrtcJwt'][0])
    {
        list($response) = $this->makeAWebrtcJwtWithHttpInfo($create_web_rtc_token, $contentType);
        return $response;
    }     
    /**
     * Operation makeAWebrtcJwtWithHttpInfo
     *
     * Make a JWT for WebRTC calling
     *

     * @param  \FreeClimb\Api\Model\CreateWebRTCToken $create_web_rtc_token Information needed to craft a JWT compatible with the platforms WebRTC APIs (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['makeAWebrtcJwt'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function makeAWebrtcJwtWithHttpInfo($create_web_rtc_token, string $contentType = self::contentTypes['makeAWebrtcJwt'][0])
    {
        $request = $this->makeAWebrtcJwtRequest($create_web_rtc_token, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation makeAWebrtcJwtAsync
     *
     * Make a JWT for WebRTC calling
     *

     * @param  \FreeClimb\Api\Model\CreateWebRTCToken $create_web_rtc_token Information needed to craft a JWT compatible with the platforms WebRTC APIs (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['makeAWebrtcJwt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function makeAWebrtcJwtAsync($create_web_rtc_token, string $contentType = self::contentTypes['makeAWebrtcJwt'][0])
    {
        return $this->makeAWebrtcJwtAsyncWithHttpInfo($create_web_rtc_token, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation makeAWebrtcJwtAsyncWithHttpInfo
     *
     * Make a JWT for WebRTC calling
     *

     * @param  \FreeClimb\Api\Model\CreateWebRTCToken $create_web_rtc_token Information needed to craft a JWT compatible with the platforms WebRTC APIs (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['makeAWebrtcJwt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function makeAWebrtcJwtAsyncWithHttpInfo($create_web_rtc_token, string $contentType = self::contentTypes['makeAWebrtcJwt'][0])
    {
        $returnType = 'string';
        $request = $this->makeAWebrtcJwtRequest($create_web_rtc_token, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'makeAWebrtcJwt'
     *

     * @param  \FreeClimb\Api\Model\CreateWebRTCToken $create_web_rtc_token Information needed to craft a JWT compatible with the platforms WebRTC APIs (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['makeAWebrtcJwt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function makeAWebrtcJwtRequest($create_web_rtc_token, string $contentType = self::contentTypes['makeAWebrtcJwt'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'create_web_rtc_token' is set
        if ($create_web_rtc_token === null || (is_array($create_web_rtc_token) && count($create_web_rtc_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_web_rtc_token when calling makeAWebrtcJwt'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Calls/WebRTC/Token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_web_rtc_token)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_web_rtc_token));
            } else {
                $httpBody = $create_web_rtc_token;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeAParticipant
     *
     * Remove a Participant
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAParticipant'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function removeAParticipant($conference_id, $call_id, string $contentType = self::contentTypes['removeAParticipant'][0])
    {
        $this->removeAParticipantWithHttpInfo($conference_id, $call_id, $contentType);
    }     
    /**
     * Operation removeAParticipantWithHttpInfo
     *
     * Remove a Participant
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAParticipant'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeAParticipantWithHttpInfo($conference_id, $call_id, string $contentType = self::contentTypes['removeAParticipant'][0])
    {
        $request = $this->removeAParticipantRequest($conference_id, $call_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation removeAParticipantAsync
     *
     * Remove a Participant
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAParticipant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAParticipantAsync($conference_id, $call_id, string $contentType = self::contentTypes['removeAParticipant'][0])
    {
        return $this->removeAParticipantAsyncWithHttpInfo($conference_id, $call_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeAParticipantAsyncWithHttpInfo
     *
     * Remove a Participant
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAParticipant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAParticipantAsyncWithHttpInfo($conference_id, $call_id, string $contentType = self::contentTypes['removeAParticipant'][0])
    {
        $returnType = '';
        $request = $this->removeAParticipantRequest($conference_id, $call_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeAParticipant'
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAParticipant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeAParticipantRequest($conference_id, $call_id, string $contentType = self::contentTypes['removeAParticipant'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'conference_id' is set
        if ($conference_id === null || (is_array($conference_id) && count($conference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_id when calling removeAParticipant'
            );
        }

        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling removeAParticipant'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Conferences/{conferenceId}/Participants/{callId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($conference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'conferenceId' . '}',
                ObjectSerializer::toPathValue($conference_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendAnSmsMessage
     *
     * Send an SMS Message
     *

     * @param  \FreeClimb\Api\Model\MessageRequest $message_request Details to create a message (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendAnSmsMessage'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\MessageResult
     */
    public function sendAnSmsMessage($message_request, string $contentType = self::contentTypes['sendAnSmsMessage'][0])
    {
        list($response) = $this->sendAnSmsMessageWithHttpInfo($message_request, $contentType);
        return $response;
    }     
    /**
     * Operation sendAnSmsMessageWithHttpInfo
     *
     * Send an SMS Message
     *

     * @param  \FreeClimb\Api\Model\MessageRequest $message_request Details to create a message (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendAnSmsMessage'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\MessageResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendAnSmsMessageWithHttpInfo($message_request, string $contentType = self::contentTypes['sendAnSmsMessage'][0])
    {
        $request = $this->sendAnSmsMessageRequest($message_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 202:
                    if ('\FreeClimb\Api\Model\MessageResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\MessageResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\MessageResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\MessageResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\MessageResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendAnSmsMessageAsync
     *
     * Send an SMS Message
     *

     * @param  \FreeClimb\Api\Model\MessageRequest $message_request Details to create a message (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendAnSmsMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendAnSmsMessageAsync($message_request, string $contentType = self::contentTypes['sendAnSmsMessage'][0])
    {
        return $this->sendAnSmsMessageAsyncWithHttpInfo($message_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendAnSmsMessageAsyncWithHttpInfo
     *
     * Send an SMS Message
     *

     * @param  \FreeClimb\Api\Model\MessageRequest $message_request Details to create a message (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendAnSmsMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendAnSmsMessageAsyncWithHttpInfo($message_request, string $contentType = self::contentTypes['sendAnSmsMessage'][0])
    {
        $returnType = '\FreeClimb\Api\Model\MessageResult';
        $request = $this->sendAnSmsMessageRequest($message_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendAnSmsMessage'
     *

     * @param  \FreeClimb\Api\Model\MessageRequest $message_request Details to create a message (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendAnSmsMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendAnSmsMessageRequest($message_request, string $contentType = self::contentTypes['sendAnSmsMessage'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'message_request' is set
        if ($message_request === null || (is_array($message_request) && count($message_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_request when calling sendAnSmsMessage'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($message_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($message_request));
            } else {
                $httpBody = $message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation streamARecordingFile
     *
     * Stream a Recording File
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['streamARecordingFile'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function streamARecordingFile($recording_id, string $contentType = self::contentTypes['streamARecordingFile'][0])
    {
        list($response) = $this->streamARecordingFileWithHttpInfo($recording_id, $contentType);
        return $response;
    }     
    /**
     * Operation streamARecordingFileWithHttpInfo
     *
     * Stream a Recording File
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['streamARecordingFile'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamARecordingFileWithHttpInfo($recording_id, string $contentType = self::contentTypes['streamARecordingFile'][0])
    {
        $request = $this->streamARecordingFileRequest($recording_id, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation streamARecordingFileAsync
     *
     * Stream a Recording File
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['streamARecordingFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function streamARecordingFileAsync($recording_id, string $contentType = self::contentTypes['streamARecordingFile'][0])
    {
        return $this->streamARecordingFileAsyncWithHttpInfo($recording_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation streamARecordingFileAsyncWithHttpInfo
     *
     * Stream a Recording File
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['streamARecordingFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function streamARecordingFileAsyncWithHttpInfo($recording_id, string $contentType = self::contentTypes['streamARecordingFile'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->streamARecordingFileRequest($recording_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'streamARecordingFile'
     *

     * @param  string $recording_id String that uniquely identifies this recording resource. (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['streamARecordingFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function streamARecordingFileRequest($recording_id, string $contentType = self::contentTypes['streamARecordingFile'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'recording_id' is set
        if ($recording_id === null || (is_array($recording_id) && count($recording_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_id when calling streamARecordingFile'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Recordings/{recordingId}/Stream';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($recording_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recordingId' . '}',
                ObjectSerializer::toPathValue($recording_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['audio/x-wav', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAConference
     *
     * Update a Conference
     *

     * @param  string $conference_id String that uniquely identifies this conference resource. (required)

     * @param  \FreeClimb\Api\Model\UpdateConferenceRequest $update_conference_request Conference Details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAConference'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateAConference($conference_id, $update_conference_request = null, string $contentType = self::contentTypes['updateAConference'][0])
    {
        $this->updateAConferenceWithHttpInfo($conference_id, $update_conference_request, $contentType);
    }     
    /**
     * Operation updateAConferenceWithHttpInfo
     *
     * Update a Conference
     *

     * @param  string $conference_id String that uniquely identifies this conference resource. (required)

     * @param  \FreeClimb\Api\Model\UpdateConferenceRequest $update_conference_request Conference Details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAConference'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAConferenceWithHttpInfo($conference_id, $update_conference_request = null, string $contentType = self::contentTypes['updateAConference'][0])
    {
        $request = $this->updateAConferenceRequest($conference_id, $update_conference_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateAConferenceAsync
     *
     * Update a Conference
     *

     * @param  string $conference_id String that uniquely identifies this conference resource. (required)

     * @param  \FreeClimb\Api\Model\UpdateConferenceRequest $update_conference_request Conference Details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAConference'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAConferenceAsync($conference_id, $update_conference_request = null, string $contentType = self::contentTypes['updateAConference'][0])
    {
        return $this->updateAConferenceAsyncWithHttpInfo($conference_id, $update_conference_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAConferenceAsyncWithHttpInfo
     *
     * Update a Conference
     *

     * @param  string $conference_id String that uniquely identifies this conference resource. (required)

     * @param  \FreeClimb\Api\Model\UpdateConferenceRequest $update_conference_request Conference Details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAConference'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAConferenceAsyncWithHttpInfo($conference_id, $update_conference_request = null, string $contentType = self::contentTypes['updateAConference'][0])
    {
        $returnType = '';
        $request = $this->updateAConferenceRequest($conference_id, $update_conference_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAConference'
     *

     * @param  string $conference_id String that uniquely identifies this conference resource. (required)

     * @param  \FreeClimb\Api\Model\UpdateConferenceRequest $update_conference_request Conference Details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAConference'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAConferenceRequest($conference_id, $update_conference_request = null, string $contentType = self::contentTypes['updateAConference'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'conference_id' is set
        if ($conference_id === null || (is_array($conference_id) && count($conference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_id when calling updateAConference'
            );
        }




        $resourcePath = '/Accounts/{accountId}/Conferences/{conferenceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($conference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'conferenceId' . '}',
                ObjectSerializer::toPathValue($conference_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_conference_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_conference_request));
            } else {
                $httpBody = $update_conference_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateALiveCall
     *
     * Update a Live Call
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  \FreeClimb\Api\Model\UpdateCallRequest $update_call_request Call details to update (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateALiveCall'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateALiveCall($call_id, $update_call_request, string $contentType = self::contentTypes['updateALiveCall'][0])
    {
        $this->updateALiveCallWithHttpInfo($call_id, $update_call_request, $contentType);
    }     
    /**
     * Operation updateALiveCallWithHttpInfo
     *
     * Update a Live Call
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  \FreeClimb\Api\Model\UpdateCallRequest $update_call_request Call details to update (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateALiveCall'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateALiveCallWithHttpInfo($call_id, $update_call_request, string $contentType = self::contentTypes['updateALiveCall'][0])
    {
        $request = $this->updateALiveCallRequest($call_id, $update_call_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateALiveCallAsync
     *
     * Update a Live Call
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  \FreeClimb\Api\Model\UpdateCallRequest $update_call_request Call details to update (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateALiveCall'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateALiveCallAsync($call_id, $update_call_request, string $contentType = self::contentTypes['updateALiveCall'][0])
    {
        return $this->updateALiveCallAsyncWithHttpInfo($call_id, $update_call_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateALiveCallAsyncWithHttpInfo
     *
     * Update a Live Call
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  \FreeClimb\Api\Model\UpdateCallRequest $update_call_request Call details to update (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateALiveCall'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateALiveCallAsyncWithHttpInfo($call_id, $update_call_request, string $contentType = self::contentTypes['updateALiveCall'][0])
    {
        $returnType = '';
        $request = $this->updateALiveCallRequest($call_id, $update_call_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateALiveCall'
     *

     * @param  string $call_id String that uniquely identifies this call resource. (required)

     * @param  \FreeClimb\Api\Model\UpdateCallRequest $update_call_request Call details to update (required)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateALiveCall'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateALiveCallRequest($call_id, $update_call_request, string $contentType = self::contentTypes['updateALiveCall'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling updateALiveCall'
            );
        }

        // verify the required parameter 'update_call_request' is set
        if ($update_call_request === null || (is_array($update_call_request) && count($update_call_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_call_request when calling updateALiveCall'
            );
        }



        $resourcePath = '/Accounts/{accountId}/Calls/{callId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_call_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_call_request));
            } else {
                $httpBody = $update_call_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAParticipant
     *
     * Update a Participant
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  \FreeClimb\Api\Model\UpdateConferenceParticipantRequest $update_conference_participant_request Conference participant details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAParticipant'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\ConferenceParticipantResult
     */
    public function updateAParticipant($conference_id, $call_id, $update_conference_participant_request = null, string $contentType = self::contentTypes['updateAParticipant'][0])
    {
        list($response) = $this->updateAParticipantWithHttpInfo($conference_id, $call_id, $update_conference_participant_request, $contentType);
        return $response;
    }     
    /**
     * Operation updateAParticipantWithHttpInfo
     *
     * Update a Participant
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  \FreeClimb\Api\Model\UpdateConferenceParticipantRequest $update_conference_participant_request Conference participant details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAParticipant'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\ConferenceParticipantResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAParticipantWithHttpInfo($conference_id, $call_id, $update_conference_participant_request = null, string $contentType = self::contentTypes['updateAParticipant'][0])
    {
        $request = $this->updateAParticipantRequest($conference_id, $call_id, $update_conference_participant_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\ConferenceParticipantResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\ConferenceParticipantResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\ConferenceParticipantResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\ConferenceParticipantResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\ConferenceParticipantResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAParticipantAsync
     *
     * Update a Participant
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  \FreeClimb\Api\Model\UpdateConferenceParticipantRequest $update_conference_participant_request Conference participant details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAParticipant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAParticipantAsync($conference_id, $call_id, $update_conference_participant_request = null, string $contentType = self::contentTypes['updateAParticipant'][0])
    {
        return $this->updateAParticipantAsyncWithHttpInfo($conference_id, $call_id, $update_conference_participant_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAParticipantAsyncWithHttpInfo
     *
     * Update a Participant
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  \FreeClimb\Api\Model\UpdateConferenceParticipantRequest $update_conference_participant_request Conference participant details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAParticipant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAParticipantAsyncWithHttpInfo($conference_id, $call_id, $update_conference_participant_request = null, string $contentType = self::contentTypes['updateAParticipant'][0])
    {
        $returnType = '\FreeClimb\Api\Model\ConferenceParticipantResult';
        $request = $this->updateAParticipantRequest($conference_id, $call_id, $update_conference_participant_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAParticipant'
     *

     * @param  string $conference_id ID of the conference this participant is in. (required)

     * @param  string $call_id ID of the Call associated with this participant. (required)

     * @param  \FreeClimb\Api\Model\UpdateConferenceParticipantRequest $update_conference_participant_request Conference participant details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAParticipant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAParticipantRequest($conference_id, $call_id, $update_conference_participant_request = null, string $contentType = self::contentTypes['updateAParticipant'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'conference_id' is set
        if ($conference_id === null || (is_array($conference_id) && count($conference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_id when calling updateAParticipant'
            );
        }

        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling updateAParticipant'
            );
        }




        $resourcePath = '/Accounts/{accountId}/Conferences/{conferenceId}/Participants/{callId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($conference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'conferenceId' . '}',
                ObjectSerializer::toPathValue($conference_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_conference_participant_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_conference_participant_request));
            } else {
                $httpBody = $update_conference_participant_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAQueue
     *
     * Update a Queue
     *

     * @param  string $queue_id A string that uniquely identifies this Queue resource. (required)

     * @param  \FreeClimb\Api\Model\QueueRequest $queue_request Queue Details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAQueue'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\QueueResult
     */
    public function updateAQueue($queue_id, $queue_request = null, string $contentType = self::contentTypes['updateAQueue'][0])
    {
        list($response) = $this->updateAQueueWithHttpInfo($queue_id, $queue_request, $contentType);
        return $response;
    }     
    /**
     * Operation updateAQueueWithHttpInfo
     *
     * Update a Queue
     *

     * @param  string $queue_id A string that uniquely identifies this Queue resource. (required)

     * @param  \FreeClimb\Api\Model\QueueRequest $queue_request Queue Details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAQueue'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\QueueResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAQueueWithHttpInfo($queue_id, $queue_request = null, string $contentType = self::contentTypes['updateAQueue'][0])
    {
        $request = $this->updateAQueueRequest($queue_id, $queue_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\QueueResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\QueueResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\QueueResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\QueueResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\QueueResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAQueueAsync
     *
     * Update a Queue
     *

     * @param  string $queue_id A string that uniquely identifies this Queue resource. (required)

     * @param  \FreeClimb\Api\Model\QueueRequest $queue_request Queue Details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAQueueAsync($queue_id, $queue_request = null, string $contentType = self::contentTypes['updateAQueue'][0])
    {
        return $this->updateAQueueAsyncWithHttpInfo($queue_id, $queue_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAQueueAsyncWithHttpInfo
     *
     * Update a Queue
     *

     * @param  string $queue_id A string that uniquely identifies this Queue resource. (required)

     * @param  \FreeClimb\Api\Model\QueueRequest $queue_request Queue Details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAQueueAsyncWithHttpInfo($queue_id, $queue_request = null, string $contentType = self::contentTypes['updateAQueue'][0])
    {
        $returnType = '\FreeClimb\Api\Model\QueueResult';
        $request = $this->updateAQueueRequest($queue_id, $queue_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAQueue'
     *

     * @param  string $queue_id A string that uniquely identifies this Queue resource. (required)

     * @param  \FreeClimb\Api\Model\QueueRequest $queue_request Queue Details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAQueueRequest($queue_id, $queue_request = null, string $contentType = self::contentTypes['updateAQueue'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'queue_id' is set
        if ($queue_id === null || (is_array($queue_id) && count($queue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_id when calling updateAQueue'
            );
        }




        $resourcePath = '/Accounts/{accountId}/Queues/{queueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($queue_id !== null) {
            $resourcePath = str_replace(
                '{' . 'queueId' . '}',
                ObjectSerializer::toPathValue($queue_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($queue_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($queue_request));
            } else {
                $httpBody = $queue_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAnAccount
     *
     * Manage an account
     *

     * @param  \FreeClimb\Api\Model\AccountRequest $account_request Account details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnAccount'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateAnAccount($account_request = null, string $contentType = self::contentTypes['updateAnAccount'][0])
    {
        $this->updateAnAccountWithHttpInfo($account_request, $contentType);
    }     
    /**
     * Operation updateAnAccountWithHttpInfo
     *
     * Manage an account
     *

     * @param  \FreeClimb\Api\Model\AccountRequest $account_request Account details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnAccount'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAnAccountWithHttpInfo($account_request = null, string $contentType = self::contentTypes['updateAnAccount'][0])
    {
        $request = $this->updateAnAccountRequest($account_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateAnAccountAsync
     *
     * Manage an account
     *

     * @param  \FreeClimb\Api\Model\AccountRequest $account_request Account details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnAccountAsync($account_request = null, string $contentType = self::contentTypes['updateAnAccount'][0])
    {
        return $this->updateAnAccountAsyncWithHttpInfo($account_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAnAccountAsyncWithHttpInfo
     *
     * Manage an account
     *

     * @param  \FreeClimb\Api\Model\AccountRequest $account_request Account details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnAccountAsyncWithHttpInfo($account_request = null, string $contentType = self::contentTypes['updateAnAccount'][0])
    {
        $returnType = '';
        $request = $this->updateAnAccountRequest($account_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAnAccount'
     *

     * @param  \FreeClimb\Api\Model\AccountRequest $account_request Account details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAnAccountRequest($account_request = null, string $contentType = self::contentTypes['updateAnAccount'][0])
    {
        $account_id = $this->config->getUsername();




        $resourcePath = '/Accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($account_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($account_request));
            } else {
                $httpBody = $account_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAnApplication
     *
     * Update an application
     *

     * @param  string $application_id A string that uniquely identifies this application resource. (required)

     * @param  \FreeClimb\Api\Model\ApplicationRequest $application_request Application details to update. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnApplication'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\ApplicationResult
     */
    public function updateAnApplication($application_id, $application_request = null, string $contentType = self::contentTypes['updateAnApplication'][0])
    {
        list($response) = $this->updateAnApplicationWithHttpInfo($application_id, $application_request, $contentType);
        return $response;
    }     
    /**
     * Operation updateAnApplicationWithHttpInfo
     *
     * Update an application
     *

     * @param  string $application_id A string that uniquely identifies this application resource. (required)

     * @param  \FreeClimb\Api\Model\ApplicationRequest $application_request Application details to update. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnApplication'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\ApplicationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAnApplicationWithHttpInfo($application_id, $application_request = null, string $contentType = self::contentTypes['updateAnApplication'][0])
    {
        $request = $this->updateAnApplicationRequest($application_id, $application_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\ApplicationResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\ApplicationResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\ApplicationResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\ApplicationResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\ApplicationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAnApplicationAsync
     *
     * Update an application
     *

     * @param  string $application_id A string that uniquely identifies this application resource. (required)

     * @param  \FreeClimb\Api\Model\ApplicationRequest $application_request Application details to update. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnApplication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnApplicationAsync($application_id, $application_request = null, string $contentType = self::contentTypes['updateAnApplication'][0])
    {
        return $this->updateAnApplicationAsyncWithHttpInfo($application_id, $application_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAnApplicationAsyncWithHttpInfo
     *
     * Update an application
     *

     * @param  string $application_id A string that uniquely identifies this application resource. (required)

     * @param  \FreeClimb\Api\Model\ApplicationRequest $application_request Application details to update. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnApplication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnApplicationAsyncWithHttpInfo($application_id, $application_request = null, string $contentType = self::contentTypes['updateAnApplication'][0])
    {
        $returnType = '\FreeClimb\Api\Model\ApplicationResult';
        $request = $this->updateAnApplicationRequest($application_id, $application_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAnApplication'
     *

     * @param  string $application_id A string that uniquely identifies this application resource. (required)

     * @param  \FreeClimb\Api\Model\ApplicationRequest $application_request Application details to update. (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnApplication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAnApplicationRequest($application_id, $application_request = null, string $contentType = self::contentTypes['updateAnApplication'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling updateAnApplication'
            );
        }




        $resourcePath = '/Accounts/{accountId}/Applications/{applicationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($application_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($application_request));
            } else {
                $httpBody = $application_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAnIncomingNumber
     *
     * Update an Incoming Number
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  \FreeClimb\Api\Model\IncomingNumberRequest $incoming_number_request Incoming Number details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\IncomingNumberResult
     */
    public function updateAnIncomingNumber($phone_number_id, $incoming_number_request = null, string $contentType = self::contentTypes['updateAnIncomingNumber'][0])
    {
        list($response) = $this->updateAnIncomingNumberWithHttpInfo($phone_number_id, $incoming_number_request, $contentType);
        return $response;
    }     
    /**
     * Operation updateAnIncomingNumberWithHttpInfo
     *
     * Update an Incoming Number
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  \FreeClimb\Api\Model\IncomingNumberRequest $incoming_number_request Incoming Number details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\IncomingNumberResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAnIncomingNumberWithHttpInfo($phone_number_id, $incoming_number_request = null, string $contentType = self::contentTypes['updateAnIncomingNumber'][0])
    {
        $request = $this->updateAnIncomingNumberRequest($phone_number_id, $incoming_number_request, $contentType);        

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch ($statusCode) {
                case 200:
                    if ('\FreeClimb\Api\Model\IncomingNumberResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\FreeClimb\Api\Model\IncomingNumberResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\Api\Model\IncomingNumberResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\FreeClimb\Api\Model\IncomingNumberResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\IncomingNumberResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAnIncomingNumberAsync
     *
     * Update an Incoming Number
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  \FreeClimb\Api\Model\IncomingNumberRequest $incoming_number_request Incoming Number details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnIncomingNumberAsync($phone_number_id, $incoming_number_request = null, string $contentType = self::contentTypes['updateAnIncomingNumber'][0])
    {
        return $this->updateAnIncomingNumberAsyncWithHttpInfo($phone_number_id, $incoming_number_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAnIncomingNumberAsyncWithHttpInfo
     *
     * Update an Incoming Number
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  \FreeClimb\Api\Model\IncomingNumberRequest $incoming_number_request Incoming Number details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnIncomingNumberAsyncWithHttpInfo($phone_number_id, $incoming_number_request = null, string $contentType = self::contentTypes['updateAnIncomingNumber'][0])
    {
        $returnType = '\FreeClimb\Api\Model\IncomingNumberResult';
        $request = $this->updateAnIncomingNumberRequest($phone_number_id, $incoming_number_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAnIncomingNumber'
     *

     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)

     * @param  \FreeClimb\Api\Model\IncomingNumberRequest $incoming_number_request Incoming Number details to update (optional)

     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnIncomingNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAnIncomingNumberRequest($phone_number_id, $incoming_number_request = null, string $contentType = self::contentTypes['updateAnIncomingNumber'][0])
    {
        $account_id = $this->config->getUsername();

        // verify the required parameter 'phone_number_id' is set
        if ($phone_number_id === null || (is_array($phone_number_id) && count($phone_number_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phone_number_id when calling updateAnIncomingNumber'
            );
        }




        $resourcePath = '/Accounts/{accountId}/IncomingPhoneNumbers/{phoneNumberId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($phone_number_id !== null) {
            $resourcePath = str_replace(
                '{' . 'phoneNumberId' . '}',
                ObjectSerializer::toPathValue($phone_number_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($incoming_number_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($incoming_number_request));
            } else {
                $httpBody = $incoming_number_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    /**
     * Operation getNextPage
     *
     * Get next page of resource
     *

     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\Api\Model\PaginationModel
     */
    public function getNextPage($initialResponse)
    {
        list($response) = $this->getNextPageWithHttpInfo($initialResponse);
        return $response;
    }

    /**
     * Operation getNextPageWithHttpInfo
     *
     * Get next page or resource
     *

     *
     * @throws \FreeClimb\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\Api\Model\PaginationModel, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNextPageWithHttpInfo($initialResponse)
    {
        $request = $this->getNextPageRequest($initialResponse['next_page_uri']);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    $content = (string) $response->getBody();

                    return [
                        ObjectSerializer::deserialize($content, get_class($initialResponse), []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = get_class($initialResponse);
            $content = (string) $response->getBody();

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\Api\Model\PaginationModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getNextPage'
     *

     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNextPageRequest($resourcePath)
    {
        $account_id = $this->config->getUsername();
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getNextPage'
            );
        }

        $formParams = [];
        $httpBody = '';

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        $contentType = "application/json";
        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            false
        );

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headers
        );

        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath,
            $headers,
            $httpBody
        );
    }
}
