<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  FreeClimb
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * FreeClimb API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.2.2
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace FreeClimb\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use FreeClimb\ApiException;
use FreeClimb\Configuration;
use FreeClimb\HeaderSelector;
use FreeClimb\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  FreeClimb
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation buyAPhoneNumber
     *
     * Buy a Phone Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  \FreeClimb\PerCL\BuyIncomingNumberRequest $buy_incoming_number_request Incoming Number transaction details (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\IncomingNumberResult
     */
    public function buyAPhoneNumber($account_id, $buy_incoming_number_request = null)
    {
        list($response) = $this->buyAPhoneNumberWithHttpInfo($account_id, $buy_incoming_number_request);
        return $response;
    }

    /**
     * Operation buyAPhoneNumberWithHttpInfo
     *
     * Buy a Phone Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  \FreeClimb\PerCL\BuyIncomingNumberRequest $buy_incoming_number_request Incoming Number transaction details (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\IncomingNumberResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function buyAPhoneNumberWithHttpInfo($account_id, $buy_incoming_number_request = null)
    {
        $request = $this->buyAPhoneNumberRequest($account_id, $buy_incoming_number_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\IncomingNumberResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\IncomingNumberResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\IncomingNumberResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\IncomingNumberResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buyAPhoneNumberAsync
     *
     * Buy a Phone Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  \FreeClimb\PerCL\BuyIncomingNumberRequest $buy_incoming_number_request Incoming Number transaction details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buyAPhoneNumberAsync($account_id, $buy_incoming_number_request = null)
    {
        return $this->buyAPhoneNumberAsyncWithHttpInfo($account_id, $buy_incoming_number_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buyAPhoneNumberAsyncWithHttpInfo
     *
     * Buy a Phone Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  \FreeClimb\PerCL\BuyIncomingNumberRequest $buy_incoming_number_request Incoming Number transaction details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buyAPhoneNumberAsyncWithHttpInfo($account_id, $buy_incoming_number_request = null)
    {
        $returnType = '\FreeClimb\PerCL\IncomingNumberResult';
        $request = $this->buyAPhoneNumberRequest($account_id, $buy_incoming_number_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buyAPhoneNumber'
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  \FreeClimb\PerCL\BuyIncomingNumberRequest $buy_incoming_number_request Incoming Number transaction details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buyAPhoneNumberRequest($account_id, $buy_incoming_number_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling buyAPhoneNumber'
            );
        }

        $resourcePath = '/Accounts/{accountId}/IncomingPhoneNumbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($buy_incoming_number_request)) {
            $_tempBody = $buy_incoming_number_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAConference
     *
     * Create a Conference
     *
     * @param  string $account_id ID of the account that created this Conference. (required)
     * @param  \FreeClimb\PerCL\CreateConferenceRequest $create_conference_request Conference to create (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\ConferenceResult
     */
    public function createAConference($account_id, $create_conference_request = null)
    {
        list($response) = $this->createAConferenceWithHttpInfo($account_id, $create_conference_request);
        return $response;
    }

    /**
     * Operation createAConferenceWithHttpInfo
     *
     * Create a Conference
     *
     * @param  string $account_id ID of the account that created this Conference. (required)
     * @param  \FreeClimb\PerCL\CreateConferenceRequest $create_conference_request Conference to create (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\ConferenceResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAConferenceWithHttpInfo($account_id, $create_conference_request = null)
    {
        $request = $this->createAConferenceRequest($account_id, $create_conference_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\ConferenceResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\ConferenceResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\ConferenceResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\ConferenceResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAConferenceAsync
     *
     * Create a Conference
     *
     * @param  string $account_id ID of the account that created this Conference. (required)
     * @param  \FreeClimb\PerCL\CreateConferenceRequest $create_conference_request Conference to create (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAConferenceAsync($account_id, $create_conference_request = null)
    {
        return $this->createAConferenceAsyncWithHttpInfo($account_id, $create_conference_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAConferenceAsyncWithHttpInfo
     *
     * Create a Conference
     *
     * @param  string $account_id ID of the account that created this Conference. (required)
     * @param  \FreeClimb\PerCL\CreateConferenceRequest $create_conference_request Conference to create (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAConferenceAsyncWithHttpInfo($account_id, $create_conference_request = null)
    {
        $returnType = '\FreeClimb\PerCL\ConferenceResult';
        $request = $this->createAConferenceRequest($account_id, $create_conference_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAConference'
     *
     * @param  string $account_id ID of the account that created this Conference. (required)
     * @param  \FreeClimb\PerCL\CreateConferenceRequest $create_conference_request Conference to create (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createAConferenceRequest($account_id, $create_conference_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createAConference'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Conferences';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($create_conference_request)) {
            $_tempBody = $create_conference_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAQueue
     *
     * Create a Queue
     *
     * @param  string $account_id ID of the account that created this Queue. (required)
     * @param  \FreeClimb\PerCL\QueueRequest $queue_request Queue details used to create a queue (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\QueueResult
     */
    public function createAQueue($account_id, $queue_request = null)
    {
        list($response) = $this->createAQueueWithHttpInfo($account_id, $queue_request);
        return $response;
    }

    /**
     * Operation createAQueueWithHttpInfo
     *
     * Create a Queue
     *
     * @param  string $account_id ID of the account that created this Queue. (required)
     * @param  \FreeClimb\PerCL\QueueRequest $queue_request Queue details used to create a queue (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\QueueResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAQueueWithHttpInfo($account_id, $queue_request = null)
    {
        $request = $this->createAQueueRequest($account_id, $queue_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\QueueResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\QueueResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\QueueResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\QueueResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAQueueAsync
     *
     * Create a Queue
     *
     * @param  string $account_id ID of the account that created this Queue. (required)
     * @param  \FreeClimb\PerCL\QueueRequest $queue_request Queue details used to create a queue (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAQueueAsync($account_id, $queue_request = null)
    {
        return $this->createAQueueAsyncWithHttpInfo($account_id, $queue_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAQueueAsyncWithHttpInfo
     *
     * Create a Queue
     *
     * @param  string $account_id ID of the account that created this Queue. (required)
     * @param  \FreeClimb\PerCL\QueueRequest $queue_request Queue details used to create a queue (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAQueueAsyncWithHttpInfo($account_id, $queue_request = null)
    {
        $returnType = '\FreeClimb\PerCL\QueueResult';
        $request = $this->createAQueueRequest($account_id, $queue_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAQueue'
     *
     * @param  string $account_id ID of the account that created this Queue. (required)
     * @param  \FreeClimb\PerCL\QueueRequest $queue_request Queue details used to create a queue (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createAQueueRequest($account_id, $queue_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createAQueue'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Queues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($queue_request)) {
            $_tempBody = $queue_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAnApplication
     *
     * Create an application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  \FreeClimb\PerCL\ApplicationRequest $application_request Application Details (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\ApplicationResult
     */
    public function createAnApplication($account_id, $application_request = null)
    {
        list($response) = $this->createAnApplicationWithHttpInfo($account_id, $application_request);
        return $response;
    }

    /**
     * Operation createAnApplicationWithHttpInfo
     *
     * Create an application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  \FreeClimb\PerCL\ApplicationRequest $application_request Application Details (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\ApplicationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAnApplicationWithHttpInfo($account_id, $application_request = null)
    {
        $request = $this->createAnApplicationRequest($account_id, $application_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 201:
                    if ('\FreeClimb\PerCL\ApplicationResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\ApplicationResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\ApplicationResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\ApplicationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAnApplicationAsync
     *
     * Create an application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  \FreeClimb\PerCL\ApplicationRequest $application_request Application Details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAnApplicationAsync($account_id, $application_request = null)
    {
        return $this->createAnApplicationAsyncWithHttpInfo($account_id, $application_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAnApplicationAsyncWithHttpInfo
     *
     * Create an application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  \FreeClimb\PerCL\ApplicationRequest $application_request Application Details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAnApplicationAsyncWithHttpInfo($account_id, $application_request = null)
    {
        $returnType = '\FreeClimb\PerCL\ApplicationResult';
        $request = $this->createAnApplicationRequest($account_id, $application_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAnApplication'
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  \FreeClimb\PerCL\ApplicationRequest $application_request Application Details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createAnApplicationRequest($account_id, $application_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createAnApplication'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Applications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($application_request)) {
            $_tempBody = $application_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteARecording
     *
     * Delete a Recording
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteARecording($account_id, $recording_id)
    {
        $this->deleteARecordingWithHttpInfo($account_id, $recording_id);
    }

    /**
     * Operation deleteARecordingWithHttpInfo
     *
     * Delete a Recording
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteARecordingWithHttpInfo($account_id, $recording_id)
    {
        $request = $this->deleteARecordingRequest($account_id, $recording_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteARecordingAsync
     *
     * Delete a Recording
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteARecordingAsync($account_id, $recording_id)
    {
        return $this->deleteARecordingAsyncWithHttpInfo($account_id, $recording_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteARecordingAsyncWithHttpInfo
     *
     * Delete a Recording
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteARecordingAsyncWithHttpInfo($account_id, $recording_id)
    {
        $returnType = '';
        $request = $this->deleteARecordingRequest($account_id, $recording_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteARecording'
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteARecordingRequest($account_id, $recording_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteARecording'
            );
        }
        // verify the required parameter 'recording_id' is set
        if ($recording_id === null || (is_array($recording_id) && count($recording_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_id when calling deleteARecording'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Recordings/{recordingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($recording_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recordingId' . '}',
                ObjectSerializer::toPathValue($recording_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAnApplication
     *
     * Delete an application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id String that uniquely identifies this application resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAnApplication($account_id, $application_id)
    {
        $this->deleteAnApplicationWithHttpInfo($account_id, $application_id);
    }

    /**
     * Operation deleteAnApplicationWithHttpInfo
     *
     * Delete an application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id String that uniquely identifies this application resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAnApplicationWithHttpInfo($account_id, $application_id)
    {
        $request = $this->deleteAnApplicationRequest($account_id, $application_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAnApplicationAsync
     *
     * Delete an application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id String that uniquely identifies this application resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAnApplicationAsync($account_id, $application_id)
    {
        return $this->deleteAnApplicationAsyncWithHttpInfo($account_id, $application_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAnApplicationAsyncWithHttpInfo
     *
     * Delete an application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id String that uniquely identifies this application resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAnApplicationAsyncWithHttpInfo($account_id, $application_id)
    {
        $returnType = '';
        $request = $this->deleteAnApplicationRequest($account_id, $application_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAnApplication'
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id String that uniquely identifies this application resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteAnApplicationRequest($account_id, $application_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteAnApplication'
            );
        }
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling deleteAnApplication'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Applications/{applicationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAnIncomingNumber
     *
     * Delete an Incoming Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAnIncomingNumber($account_id, $phone_number_id)
    {
        $this->deleteAnIncomingNumberWithHttpInfo($account_id, $phone_number_id);
    }

    /**
     * Operation deleteAnIncomingNumberWithHttpInfo
     *
     * Delete an Incoming Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAnIncomingNumberWithHttpInfo($account_id, $phone_number_id)
    {
        $request = $this->deleteAnIncomingNumberRequest($account_id, $phone_number_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAnIncomingNumberAsync
     *
     * Delete an Incoming Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAnIncomingNumberAsync($account_id, $phone_number_id)
    {
        return $this->deleteAnIncomingNumberAsyncWithHttpInfo($account_id, $phone_number_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAnIncomingNumberAsyncWithHttpInfo
     *
     * Delete an Incoming Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAnIncomingNumberAsyncWithHttpInfo($account_id, $phone_number_id)
    {
        $returnType = '';
        $request = $this->deleteAnIncomingNumberRequest($account_id, $phone_number_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAnIncomingNumber'
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteAnIncomingNumberRequest($account_id, $phone_number_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteAnIncomingNumber'
            );
        }
        // verify the required parameter 'phone_number_id' is set
        if ($phone_number_id === null || (is_array($phone_number_id) && count($phone_number_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phone_number_id when calling deleteAnIncomingNumber'
            );
        }

        $resourcePath = '/Accounts/{accountId}/IncomingPhoneNumbers/{phoneNumberId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($phone_number_id !== null) {
            $resourcePath = str_replace(
                '{' . 'phoneNumberId' . '}',
                ObjectSerializer::toPathValue($phone_number_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dequeueAMember
     *
     * Dequeue a Member
     *
     * @param  string $account_id ID of the account that created the Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     * @param  string $call_id ID if the Call that the Member belongs to (required)
     * @param  \FreeClimb\PerCL\DequeueMemberRequest $dequeue_member_request Dequeue member request details (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\QueueMember
     */
    public function dequeueAMember($account_id, $queue_id, $call_id, $dequeue_member_request = null)
    {
        list($response) = $this->dequeueAMemberWithHttpInfo($account_id, $queue_id, $call_id, $dequeue_member_request);
        return $response;
    }

    /**
     * Operation dequeueAMemberWithHttpInfo
     *
     * Dequeue a Member
     *
     * @param  string $account_id ID of the account that created the Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     * @param  string $call_id ID if the Call that the Member belongs to (required)
     * @param  \FreeClimb\PerCL\DequeueMemberRequest $dequeue_member_request Dequeue member request details (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\QueueMember, HTTP status code, HTTP response headers (array of strings)
     */
    public function dequeueAMemberWithHttpInfo($account_id, $queue_id, $call_id, $dequeue_member_request = null)
    {
        $request = $this->dequeueAMemberRequest($account_id, $queue_id, $call_id, $dequeue_member_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 202:
                    if ('\FreeClimb\PerCL\QueueMember' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\QueueMember', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\QueueMember';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\QueueMember',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dequeueAMemberAsync
     *
     * Dequeue a Member
     *
     * @param  string $account_id ID of the account that created the Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     * @param  string $call_id ID if the Call that the Member belongs to (required)
     * @param  \FreeClimb\PerCL\DequeueMemberRequest $dequeue_member_request Dequeue member request details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dequeueAMemberAsync($account_id, $queue_id, $call_id, $dequeue_member_request = null)
    {
        return $this->dequeueAMemberAsyncWithHttpInfo($account_id, $queue_id, $call_id, $dequeue_member_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dequeueAMemberAsyncWithHttpInfo
     *
     * Dequeue a Member
     *
     * @param  string $account_id ID of the account that created the Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     * @param  string $call_id ID if the Call that the Member belongs to (required)
     * @param  \FreeClimb\PerCL\DequeueMemberRequest $dequeue_member_request Dequeue member request details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dequeueAMemberAsyncWithHttpInfo($account_id, $queue_id, $call_id, $dequeue_member_request = null)
    {
        $returnType = '\FreeClimb\PerCL\QueueMember';
        $request = $this->dequeueAMemberRequest($account_id, $queue_id, $call_id, $dequeue_member_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dequeueAMember'
     *
     * @param  string $account_id ID of the account that created the Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     * @param  string $call_id ID if the Call that the Member belongs to (required)
     * @param  \FreeClimb\PerCL\DequeueMemberRequest $dequeue_member_request Dequeue member request details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dequeueAMemberRequest($account_id, $queue_id, $call_id, $dequeue_member_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling dequeueAMember'
            );
        }
        // verify the required parameter 'queue_id' is set
        if ($queue_id === null || (is_array($queue_id) && count($queue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_id when calling dequeueAMember'
            );
        }
        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling dequeueAMember'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Queues/{queueId}/Members/{callId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($queue_id !== null) {
            $resourcePath = str_replace(
                '{' . 'queueId' . '}',
                ObjectSerializer::toPathValue($queue_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($dequeue_member_request)) {
            $_tempBody = $dequeue_member_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dequeueHeadMember
     *
     * Dequeue Head Member
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id String that uniquely identifies this queue resource. (required)
     * @param  \FreeClimb\PerCL\DequeueMemberRequest $dequeue_member_request Dequeue head member request details (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\QueueMember
     */
    public function dequeueHeadMember($account_id, $queue_id, $dequeue_member_request = null)
    {
        list($response) = $this->dequeueHeadMemberWithHttpInfo($account_id, $queue_id, $dequeue_member_request);
        return $response;
    }

    /**
     * Operation dequeueHeadMemberWithHttpInfo
     *
     * Dequeue Head Member
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id String that uniquely identifies this queue resource. (required)
     * @param  \FreeClimb\PerCL\DequeueMemberRequest $dequeue_member_request Dequeue head member request details (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\QueueMember, HTTP status code, HTTP response headers (array of strings)
     */
    public function dequeueHeadMemberWithHttpInfo($account_id, $queue_id, $dequeue_member_request = null)
    {
        $request = $this->dequeueHeadMemberRequest($account_id, $queue_id, $dequeue_member_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 202:
                    if ('\FreeClimb\PerCL\QueueMember' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\QueueMember', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\QueueMember';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\QueueMember',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dequeueHeadMemberAsync
     *
     * Dequeue Head Member
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id String that uniquely identifies this queue resource. (required)
     * @param  \FreeClimb\PerCL\DequeueMemberRequest $dequeue_member_request Dequeue head member request details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dequeueHeadMemberAsync($account_id, $queue_id, $dequeue_member_request = null)
    {
        return $this->dequeueHeadMemberAsyncWithHttpInfo($account_id, $queue_id, $dequeue_member_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dequeueHeadMemberAsyncWithHttpInfo
     *
     * Dequeue Head Member
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id String that uniquely identifies this queue resource. (required)
     * @param  \FreeClimb\PerCL\DequeueMemberRequest $dequeue_member_request Dequeue head member request details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dequeueHeadMemberAsyncWithHttpInfo($account_id, $queue_id, $dequeue_member_request = null)
    {
        $returnType = '\FreeClimb\PerCL\QueueMember';
        $request = $this->dequeueHeadMemberRequest($account_id, $queue_id, $dequeue_member_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dequeueHeadMember'
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id String that uniquely identifies this queue resource. (required)
     * @param  \FreeClimb\PerCL\DequeueMemberRequest $dequeue_member_request Dequeue head member request details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dequeueHeadMemberRequest($account_id, $queue_id, $dequeue_member_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling dequeueHeadMember'
            );
        }
        // verify the required parameter 'queue_id' is set
        if ($queue_id === null || (is_array($queue_id) && count($queue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_id when calling dequeueHeadMember'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Queues/{queueId}/Members/Front';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($queue_id !== null) {
            $resourcePath = str_replace(
                '{' . 'queueId' . '}',
                ObjectSerializer::toPathValue($queue_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($dequeue_member_request)) {
            $_tempBody = $dequeue_member_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadARecordingFile
     *
     * Download a Recording File
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function downloadARecordingFile($account_id, $recording_id)
    {
        list($response) = $this->downloadARecordingFileWithHttpInfo($account_id, $recording_id);
        return $response;
    }

    /**
     * Operation downloadARecordingFileWithHttpInfo
     *
     * Download a Recording File
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadARecordingFileWithHttpInfo($account_id, $recording_id)
    {
        $request = $this->downloadARecordingFileRequest($account_id, $recording_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadARecordingFileAsync
     *
     * Download a Recording File
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadARecordingFileAsync($account_id, $recording_id)
    {
        return $this->downloadARecordingFileAsyncWithHttpInfo($account_id, $recording_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadARecordingFileAsyncWithHttpInfo
     *
     * Download a Recording File
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadARecordingFileAsyncWithHttpInfo($account_id, $recording_id)
    {
        $returnType = '\SplFileObject';
        $request = $this->downloadARecordingFileRequest($account_id, $recording_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadARecordingFile'
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function downloadARecordingFileRequest($account_id, $recording_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling downloadARecordingFile'
            );
        }
        // verify the required parameter 'recording_id' is set
        if ($recording_id === null || (is_array($recording_id) && count($recording_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_id when calling downloadARecordingFile'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Recordings/{recordingId}/Download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($recording_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recordingId' . '}',
                ObjectSerializer::toPathValue($recording_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['audio/x-wav']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['audio/x-wav'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation filterLogs
     *
     * Filter Logs
     *
     * @param  string $account_id ID of the account that this log was generated under. (required)
     * @param  \FreeClimb\PerCL\FilterLogsRequest $filter_logs_request Filter logs request paramters (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\LogList
     */
    public function filterLogs($account_id, $filter_logs_request = null)
    {
        list($response) = $this->filterLogsWithHttpInfo($account_id, $filter_logs_request);
        return $response;
    }

    /**
     * Operation filterLogsWithHttpInfo
     *
     * Filter Logs
     *
     * @param  string $account_id ID of the account that this log was generated under. (required)
     * @param  \FreeClimb\PerCL\FilterLogsRequest $filter_logs_request Filter logs request paramters (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\LogList, HTTP status code, HTTP response headers (array of strings)
     */
    public function filterLogsWithHttpInfo($account_id, $filter_logs_request = null)
    {
        $request = $this->filterLogsRequest($account_id, $filter_logs_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\LogList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\LogList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\LogList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\LogList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation filterLogsAsync
     *
     * Filter Logs
     *
     * @param  string $account_id ID of the account that this log was generated under. (required)
     * @param  \FreeClimb\PerCL\FilterLogsRequest $filter_logs_request Filter logs request paramters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filterLogsAsync($account_id, $filter_logs_request = null)
    {
        return $this->filterLogsAsyncWithHttpInfo($account_id, $filter_logs_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation filterLogsAsyncWithHttpInfo
     *
     * Filter Logs
     *
     * @param  string $account_id ID of the account that this log was generated under. (required)
     * @param  \FreeClimb\PerCL\FilterLogsRequest $filter_logs_request Filter logs request paramters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filterLogsAsyncWithHttpInfo($account_id, $filter_logs_request = null)
    {
        $returnType = '\FreeClimb\PerCL\LogList';
        $request = $this->filterLogsRequest($account_id, $filter_logs_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'filterLogs'
     *
     * @param  string $account_id ID of the account that this log was generated under. (required)
     * @param  \FreeClimb\PerCL\FilterLogsRequest $filter_logs_request Filter logs request paramters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function filterLogsRequest($account_id, $filter_logs_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling filterLogs'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($filter_logs_request)) {
            $_tempBody = $filter_logs_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getACall
     *
     * Get a Call
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\CallResult
     */
    public function getACall($account_id, $call_id)
    {
        list($response) = $this->getACallWithHttpInfo($account_id, $call_id);
        return $response;
    }

    /**
     * Operation getACallWithHttpInfo
     *
     * Get a Call
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\CallResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getACallWithHttpInfo($account_id, $call_id)
    {
        $request = $this->getACallRequest($account_id, $call_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\CallResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\CallResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\CallResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\CallResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getACallAsync
     *
     * Get a Call
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACallAsync($account_id, $call_id)
    {
        return $this->getACallAsyncWithHttpInfo($account_id, $call_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getACallAsyncWithHttpInfo
     *
     * Get a Call
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACallAsyncWithHttpInfo($account_id, $call_id)
    {
        $returnType = '\FreeClimb\PerCL\CallResult';
        $request = $this->getACallRequest($account_id, $call_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getACall'
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getACallRequest($account_id, $call_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getACall'
            );
        }
        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling getACall'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Calls/{callId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAConference
     *
     * Get a Conference
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $conference_id A string that uniquely identifies this conference resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\ConferenceResult
     */
    public function getAConference($account_id, $conference_id)
    {
        list($response) = $this->getAConferenceWithHttpInfo($account_id, $conference_id);
        return $response;
    }

    /**
     * Operation getAConferenceWithHttpInfo
     *
     * Get a Conference
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $conference_id A string that uniquely identifies this conference resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\ConferenceResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAConferenceWithHttpInfo($account_id, $conference_id)
    {
        $request = $this->getAConferenceRequest($account_id, $conference_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\ConferenceResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\ConferenceResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\ConferenceResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\ConferenceResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAConferenceAsync
     *
     * Get a Conference
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $conference_id A string that uniquely identifies this conference resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAConferenceAsync($account_id, $conference_id)
    {
        return $this->getAConferenceAsyncWithHttpInfo($account_id, $conference_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAConferenceAsyncWithHttpInfo
     *
     * Get a Conference
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $conference_id A string that uniquely identifies this conference resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAConferenceAsyncWithHttpInfo($account_id, $conference_id)
    {
        $returnType = '\FreeClimb\PerCL\ConferenceResult';
        $request = $this->getAConferenceRequest($account_id, $conference_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAConference'
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $conference_id A string that uniquely identifies this conference resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAConferenceRequest($account_id, $conference_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getAConference'
            );
        }
        // verify the required parameter 'conference_id' is set
        if ($conference_id === null || (is_array($conference_id) && count($conference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_id when calling getAConference'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Conferences/{conferenceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($conference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'conferenceId' . '}',
                ObjectSerializer::toPathValue($conference_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAMember
     *
     * Get a Member
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     * @param  string $call_id ID of the Call that the Member belongs to (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\QueueMember
     */
    public function getAMember($account_id, $queue_id, $call_id)
    {
        list($response) = $this->getAMemberWithHttpInfo($account_id, $queue_id, $call_id);
        return $response;
    }

    /**
     * Operation getAMemberWithHttpInfo
     *
     * Get a Member
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     * @param  string $call_id ID of the Call that the Member belongs to (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\QueueMember, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAMemberWithHttpInfo($account_id, $queue_id, $call_id)
    {
        $request = $this->getAMemberRequest($account_id, $queue_id, $call_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\QueueMember' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\QueueMember', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\QueueMember';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\QueueMember',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAMemberAsync
     *
     * Get a Member
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     * @param  string $call_id ID of the Call that the Member belongs to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAMemberAsync($account_id, $queue_id, $call_id)
    {
        return $this->getAMemberAsyncWithHttpInfo($account_id, $queue_id, $call_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAMemberAsyncWithHttpInfo
     *
     * Get a Member
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     * @param  string $call_id ID of the Call that the Member belongs to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAMemberAsyncWithHttpInfo($account_id, $queue_id, $call_id)
    {
        $returnType = '\FreeClimb\PerCL\QueueMember';
        $request = $this->getAMemberRequest($account_id, $queue_id, $call_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAMember'
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     * @param  string $call_id ID of the Call that the Member belongs to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAMemberRequest($account_id, $queue_id, $call_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getAMember'
            );
        }
        // verify the required parameter 'queue_id' is set
        if ($queue_id === null || (is_array($queue_id) && count($queue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_id when calling getAMember'
            );
        }
        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling getAMember'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Queues/{queueId}/Members/{callId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($queue_id !== null) {
            $resourcePath = str_replace(
                '{' . 'queueId' . '}',
                ObjectSerializer::toPathValue($queue_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAParticipant
     *
     * Get a Participant
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\ConferenceParticipantResult
     */
    public function getAParticipant($account_id, $conference_id, $call_id)
    {
        list($response) = $this->getAParticipantWithHttpInfo($account_id, $conference_id, $call_id);
        return $response;
    }

    /**
     * Operation getAParticipantWithHttpInfo
     *
     * Get a Participant
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\ConferenceParticipantResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAParticipantWithHttpInfo($account_id, $conference_id, $call_id)
    {
        $request = $this->getAParticipantRequest($account_id, $conference_id, $call_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\ConferenceParticipantResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\ConferenceParticipantResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\ConferenceParticipantResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\ConferenceParticipantResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAParticipantAsync
     *
     * Get a Participant
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAParticipantAsync($account_id, $conference_id, $call_id)
    {
        return $this->getAParticipantAsyncWithHttpInfo($account_id, $conference_id, $call_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAParticipantAsyncWithHttpInfo
     *
     * Get a Participant
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAParticipantAsyncWithHttpInfo($account_id, $conference_id, $call_id)
    {
        $returnType = '\FreeClimb\PerCL\ConferenceParticipantResult';
        $request = $this->getAParticipantRequest($account_id, $conference_id, $call_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAParticipant'
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAParticipantRequest($account_id, $conference_id, $call_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getAParticipant'
            );
        }
        // verify the required parameter 'conference_id' is set
        if ($conference_id === null || (is_array($conference_id) && count($conference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_id when calling getAParticipant'
            );
        }
        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling getAParticipant'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Conferences/{conferenceId}/Participants/{callId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($conference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'conferenceId' . '}',
                ObjectSerializer::toPathValue($conference_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAQueue
     *
     * Get a Queue
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id A string that uniquely identifies this queue resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\QueueResult
     */
    public function getAQueue($account_id, $queue_id)
    {
        list($response) = $this->getAQueueWithHttpInfo($account_id, $queue_id);
        return $response;
    }

    /**
     * Operation getAQueueWithHttpInfo
     *
     * Get a Queue
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id A string that uniquely identifies this queue resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\QueueResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAQueueWithHttpInfo($account_id, $queue_id)
    {
        $request = $this->getAQueueRequest($account_id, $queue_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\QueueResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\QueueResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\QueueResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\QueueResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAQueueAsync
     *
     * Get a Queue
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id A string that uniquely identifies this queue resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAQueueAsync($account_id, $queue_id)
    {
        return $this->getAQueueAsyncWithHttpInfo($account_id, $queue_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAQueueAsyncWithHttpInfo
     *
     * Get a Queue
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id A string that uniquely identifies this queue resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAQueueAsyncWithHttpInfo($account_id, $queue_id)
    {
        $returnType = '\FreeClimb\PerCL\QueueResult';
        $request = $this->getAQueueRequest($account_id, $queue_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAQueue'
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id A string that uniquely identifies this queue resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAQueueRequest($account_id, $queue_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getAQueue'
            );
        }
        // verify the required parameter 'queue_id' is set
        if ($queue_id === null || (is_array($queue_id) && count($queue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_id when calling getAQueue'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Queues/{queueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($queue_id !== null) {
            $resourcePath = str_replace(
                '{' . 'queueId' . '}',
                ObjectSerializer::toPathValue($queue_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getARecording
     *
     * Get a Recording
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\RecordingResult
     */
    public function getARecording($account_id, $recording_id)
    {
        list($response) = $this->getARecordingWithHttpInfo($account_id, $recording_id);
        return $response;
    }

    /**
     * Operation getARecordingWithHttpInfo
     *
     * Get a Recording
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\RecordingResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getARecordingWithHttpInfo($account_id, $recording_id)
    {
        $request = $this->getARecordingRequest($account_id, $recording_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\RecordingResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\RecordingResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\RecordingResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\RecordingResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getARecordingAsync
     *
     * Get a Recording
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getARecordingAsync($account_id, $recording_id)
    {
        return $this->getARecordingAsyncWithHttpInfo($account_id, $recording_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getARecordingAsyncWithHttpInfo
     *
     * Get a Recording
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getARecordingAsyncWithHttpInfo($account_id, $recording_id)
    {
        $returnType = '\FreeClimb\PerCL\RecordingResult';
        $request = $this->getARecordingRequest($account_id, $recording_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getARecording'
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getARecordingRequest($account_id, $recording_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getARecording'
            );
        }
        // verify the required parameter 'recording_id' is set
        if ($recording_id === null || (is_array($recording_id) && count($recording_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_id when calling getARecording'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Recordings/{recordingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($recording_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recordingId' . '}',
                ObjectSerializer::toPathValue($recording_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnAccount
     *
     * Get an Account
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\AccountResult
     */
    public function getAnAccount($account_id)
    {
        list($response) = $this->getAnAccountWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getAnAccountWithHttpInfo
     *
     * Get an Account
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\AccountResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnAccountWithHttpInfo($account_id)
    {
        $request = $this->getAnAccountRequest($account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\AccountResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\AccountResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\AccountResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\AccountResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnAccountAsync
     *
     * Get an Account
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnAccountAsync($account_id)
    {
        return $this->getAnAccountAsyncWithHttpInfo($account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnAccountAsyncWithHttpInfo
     *
     * Get an Account
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnAccountAsyncWithHttpInfo($account_id)
    {
        $returnType = '\FreeClimb\PerCL\AccountResult';
        $request = $this->getAnAccountRequest($account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnAccount'
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAnAccountRequest($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getAnAccount'
            );
        }

        $resourcePath = '/Accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnApplication
     *
     * Get an Application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id A string that uniquely identifies this application resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\ApplicationResult
     */
    public function getAnApplication($account_id, $application_id)
    {
        list($response) = $this->getAnApplicationWithHttpInfo($account_id, $application_id);
        return $response;
    }

    /**
     * Operation getAnApplicationWithHttpInfo
     *
     * Get an Application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id A string that uniquely identifies this application resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\ApplicationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnApplicationWithHttpInfo($account_id, $application_id)
    {
        $request = $this->getAnApplicationRequest($account_id, $application_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\ApplicationResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\ApplicationResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\ApplicationResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\ApplicationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnApplicationAsync
     *
     * Get an Application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id A string that uniquely identifies this application resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnApplicationAsync($account_id, $application_id)
    {
        return $this->getAnApplicationAsyncWithHttpInfo($account_id, $application_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnApplicationAsyncWithHttpInfo
     *
     * Get an Application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id A string that uniquely identifies this application resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnApplicationAsyncWithHttpInfo($account_id, $application_id)
    {
        $returnType = '\FreeClimb\PerCL\ApplicationResult';
        $request = $this->getAnApplicationRequest($account_id, $application_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnApplication'
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id A string that uniquely identifies this application resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAnApplicationRequest($account_id, $application_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getAnApplication'
            );
        }
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getAnApplication'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Applications/{applicationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnIncomingNumber
     *
     * Get an Incoming Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\IncomingNumberResult
     */
    public function getAnIncomingNumber($account_id, $phone_number_id)
    {
        list($response) = $this->getAnIncomingNumberWithHttpInfo($account_id, $phone_number_id);
        return $response;
    }

    /**
     * Operation getAnIncomingNumberWithHttpInfo
     *
     * Get an Incoming Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\IncomingNumberResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnIncomingNumberWithHttpInfo($account_id, $phone_number_id)
    {
        $request = $this->getAnIncomingNumberRequest($account_id, $phone_number_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\IncomingNumberResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\IncomingNumberResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\IncomingNumberResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\IncomingNumberResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnIncomingNumberAsync
     *
     * Get an Incoming Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnIncomingNumberAsync($account_id, $phone_number_id)
    {
        return $this->getAnIncomingNumberAsyncWithHttpInfo($account_id, $phone_number_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnIncomingNumberAsyncWithHttpInfo
     *
     * Get an Incoming Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnIncomingNumberAsyncWithHttpInfo($account_id, $phone_number_id)
    {
        $returnType = '\FreeClimb\PerCL\IncomingNumberResult';
        $request = $this->getAnIncomingNumberRequest($account_id, $phone_number_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnIncomingNumber'
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAnIncomingNumberRequest($account_id, $phone_number_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getAnIncomingNumber'
            );
        }
        // verify the required parameter 'phone_number_id' is set
        if ($phone_number_id === null || (is_array($phone_number_id) && count($phone_number_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phone_number_id when calling getAnIncomingNumber'
            );
        }

        $resourcePath = '/Accounts/{accountId}/IncomingPhoneNumbers/{phoneNumberId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($phone_number_id !== null) {
            $resourcePath = str_replace(
                '{' . 'phoneNumberId' . '}',
                ObjectSerializer::toPathValue($phone_number_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnSmsMessage
     *
     * Get an SMS Message
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     * @param  string $message_id String that uniquely identifies this Message resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\MessageResult
     */
    public function getAnSmsMessage($account_id, $message_id)
    {
        list($response) = $this->getAnSmsMessageWithHttpInfo($account_id, $message_id);
        return $response;
    }

    /**
     * Operation getAnSmsMessageWithHttpInfo
     *
     * Get an SMS Message
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     * @param  string $message_id String that uniquely identifies this Message resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\MessageResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnSmsMessageWithHttpInfo($account_id, $message_id)
    {
        $request = $this->getAnSmsMessageRequest($account_id, $message_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\MessageResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\MessageResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\MessageResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\MessageResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnSmsMessageAsync
     *
     * Get an SMS Message
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     * @param  string $message_id String that uniquely identifies this Message resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnSmsMessageAsync($account_id, $message_id)
    {
        return $this->getAnSmsMessageAsyncWithHttpInfo($account_id, $message_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnSmsMessageAsyncWithHttpInfo
     *
     * Get an SMS Message
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     * @param  string $message_id String that uniquely identifies this Message resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnSmsMessageAsyncWithHttpInfo($account_id, $message_id)
    {
        $returnType = '\FreeClimb\PerCL\MessageResult';
        $request = $this->getAnSmsMessageRequest($account_id, $message_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnSmsMessage'
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     * @param  string $message_id String that uniquely identifies this Message resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAnSmsMessageRequest($account_id, $message_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getAnSmsMessage'
            );
        }
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling getAnSmsMessage'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Messages/{messageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'messageId' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHeadMember
     *
     * Get Head Member
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\QueueMember
     */
    public function getHeadMember($account_id, $queue_id)
    {
        list($response) = $this->getHeadMemberWithHttpInfo($account_id, $queue_id);
        return $response;
    }

    /**
     * Operation getHeadMemberWithHttpInfo
     *
     * Get Head Member
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\QueueMember, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHeadMemberWithHttpInfo($account_id, $queue_id)
    {
        $request = $this->getHeadMemberRequest($account_id, $queue_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\QueueMember' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\QueueMember', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\QueueMember';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\QueueMember',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHeadMemberAsync
     *
     * Get Head Member
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHeadMemberAsync($account_id, $queue_id)
    {
        return $this->getHeadMemberAsyncWithHttpInfo($account_id, $queue_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHeadMemberAsyncWithHttpInfo
     *
     * Get Head Member
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHeadMemberAsyncWithHttpInfo($account_id, $queue_id)
    {
        $returnType = '\FreeClimb\PerCL\QueueMember';
        $request = $this->getHeadMemberRequest($account_id, $queue_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHeadMember'
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHeadMemberRequest($account_id, $queue_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getHeadMember'
            );
        }
        // verify the required parameter 'queue_id' is set
        if ($queue_id === null || (is_array($queue_id) && count($queue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_id when calling getHeadMember'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Queues/{queueId}/Members/Front';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($queue_id !== null) {
            $resourcePath = str_replace(
                '{' . 'queueId' . '}',
                ObjectSerializer::toPathValue($queue_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listActiveQueues
     *
     * List Active Queues
     *
     * @param  string $account_id ID of the account that created this Queue. (required)
     * @param  string $alias Return only the Queue resources with aliases that exactly match this name. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\QueueList
     */
    public function listActiveQueues($account_id, $alias = null)
    {
        list($response) = $this->listActiveQueuesWithHttpInfo($account_id, $alias);
        return $response;
    }

    /**
     * Operation listActiveQueuesWithHttpInfo
     *
     * List Active Queues
     *
     * @param  string $account_id ID of the account that created this Queue. (required)
     * @param  string $alias Return only the Queue resources with aliases that exactly match this name. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\QueueList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listActiveQueuesWithHttpInfo($account_id, $alias = null)
    {
        $request = $this->listActiveQueuesRequest($account_id, $alias);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\QueueList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\QueueList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\QueueList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\QueueList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listActiveQueuesAsync
     *
     * List Active Queues
     *
     * @param  string $account_id ID of the account that created this Queue. (required)
     * @param  string $alias Return only the Queue resources with aliases that exactly match this name. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listActiveQueuesAsync($account_id, $alias = null)
    {
        return $this->listActiveQueuesAsyncWithHttpInfo($account_id, $alias)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listActiveQueuesAsyncWithHttpInfo
     *
     * List Active Queues
     *
     * @param  string $account_id ID of the account that created this Queue. (required)
     * @param  string $alias Return only the Queue resources with aliases that exactly match this name. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listActiveQueuesAsyncWithHttpInfo($account_id, $alias = null)
    {
        $returnType = '\FreeClimb\PerCL\QueueList';
        $request = $this->listActiveQueuesRequest($account_id, $alias);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listActiveQueues'
     *
     * @param  string $account_id ID of the account that created this Queue. (required)
     * @param  string $alias Return only the Queue resources with aliases that exactly match this name. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listActiveQueuesRequest($account_id, $alias = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listActiveQueues'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Queues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($alias !== null) {
            $queryParams['alias'] = ObjectSerializer::toQueryValue($alias);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAllAccountLogs
     *
     * List All Account Logs
     *
     * @param  string $account_id ID of the account that these Logs were generated under. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\LogList
     */
    public function listAllAccountLogs($account_id)
    {
        list($response) = $this->listAllAccountLogsWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation listAllAccountLogsWithHttpInfo
     *
     * List All Account Logs
     *
     * @param  string $account_id ID of the account that these Logs were generated under. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\LogList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAllAccountLogsWithHttpInfo($account_id)
    {
        $request = $this->listAllAccountLogsRequest($account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\LogList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\LogList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\LogList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\LogList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAllAccountLogsAsync
     *
     * List All Account Logs
     *
     * @param  string $account_id ID of the account that these Logs were generated under. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAllAccountLogsAsync($account_id)
    {
        return $this->listAllAccountLogsAsyncWithHttpInfo($account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAllAccountLogsAsyncWithHttpInfo
     *
     * List All Account Logs
     *
     * @param  string $account_id ID of the account that these Logs were generated under. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAllAccountLogsAsyncWithHttpInfo($account_id)
    {
        $returnType = '\FreeClimb\PerCL\LogList';
        $request = $this->listAllAccountLogsRequest($account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAllAccountLogs'
     *
     * @param  string $account_id ID of the account that these Logs were generated under. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listAllAccountLogsRequest($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listAllAccountLogs'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAnApplication
     *
     * List applications
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $alias Return only applications with aliases that exactly match this value. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\ApplicationList
     */
    public function listAnApplication($account_id, $alias = null)
    {
        list($response) = $this->listAnApplicationWithHttpInfo($account_id, $alias);
        return $response;
    }

    /**
     * Operation listAnApplicationWithHttpInfo
     *
     * List applications
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $alias Return only applications with aliases that exactly match this value. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\ApplicationList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAnApplicationWithHttpInfo($account_id, $alias = null)
    {
        $request = $this->listAnApplicationRequest($account_id, $alias);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\ApplicationList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\ApplicationList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\ApplicationList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\ApplicationList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAnApplicationAsync
     *
     * List applications
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $alias Return only applications with aliases that exactly match this value. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAnApplicationAsync($account_id, $alias = null)
    {
        return $this->listAnApplicationAsyncWithHttpInfo($account_id, $alias)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAnApplicationAsyncWithHttpInfo
     *
     * List applications
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $alias Return only applications with aliases that exactly match this value. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAnApplicationAsyncWithHttpInfo($account_id, $alias = null)
    {
        $returnType = '\FreeClimb\PerCL\ApplicationList';
        $request = $this->listAnApplicationRequest($account_id, $alias);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAnApplication'
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $alias Return only applications with aliases that exactly match this value. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listAnApplicationRequest($account_id, $alias = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listAnApplication'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Applications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($alias !== null) {
            $queryParams['alias'] = ObjectSerializer::toQueryValue($alias);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAvailableNumbers
     *
     * List available numbers
     *
     * @param  string $alias Filter on numbers based on the formatted string of the phone number. (optional)
     * @param  string $phone_number PCRE-compatible regular expression to filter against &#x60;phoneNumber&#x60; field, which is in E.164 format. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\AvailableNumberList
     */
    public function listAvailableNumbers($alias = null, $phone_number = null)
    {
        list($response) = $this->listAvailableNumbersWithHttpInfo($alias, $phone_number);
        return $response;
    }

    /**
     * Operation listAvailableNumbersWithHttpInfo
     *
     * List available numbers
     *
     * @param  string $alias Filter on numbers based on the formatted string of the phone number. (optional)
     * @param  string $phone_number PCRE-compatible regular expression to filter against &#x60;phoneNumber&#x60; field, which is in E.164 format. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\AvailableNumberList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAvailableNumbersWithHttpInfo($alias = null, $phone_number = null)
    {
        $request = $this->listAvailableNumbersRequest($alias, $phone_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\AvailableNumberList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\AvailableNumberList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\AvailableNumberList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\AvailableNumberList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAvailableNumbersAsync
     *
     * List available numbers
     *
     * @param  string $alias Filter on numbers based on the formatted string of the phone number. (optional)
     * @param  string $phone_number PCRE-compatible regular expression to filter against &#x60;phoneNumber&#x60; field, which is in E.164 format. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAvailableNumbersAsync($alias = null, $phone_number = null)
    {
        return $this->listAvailableNumbersAsyncWithHttpInfo($alias, $phone_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAvailableNumbersAsyncWithHttpInfo
     *
     * List available numbers
     *
     * @param  string $alias Filter on numbers based on the formatted string of the phone number. (optional)
     * @param  string $phone_number PCRE-compatible regular expression to filter against &#x60;phoneNumber&#x60; field, which is in E.164 format. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAvailableNumbersAsyncWithHttpInfo($alias = null, $phone_number = null)
    {
        $returnType = '\FreeClimb\PerCL\AvailableNumberList';
        $request = $this->listAvailableNumbersRequest($alias, $phone_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAvailableNumbers'
     *
     * @param  string $alias Filter on numbers based on the formatted string of the phone number. (optional)
     * @param  string $phone_number PCRE-compatible regular expression to filter against &#x60;phoneNumber&#x60; field, which is in E.164 format. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listAvailableNumbersRequest($alias = null, $phone_number = null)
    {

        $resourcePath = '/AvailablePhoneNumbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($alias !== null) {
            $queryParams['alias'] = ObjectSerializer::toQueryValue($alias);
        }
        // query params
        if ($phone_number !== null) {
            $queryParams['phoneNumber'] = ObjectSerializer::toQueryValue($phone_number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCallLogs
     *
     * List Call Logs
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\LogList
     */
    public function listCallLogs($account_id, $call_id)
    {
        list($response) = $this->listCallLogsWithHttpInfo($account_id, $call_id);
        return $response;
    }

    /**
     * Operation listCallLogsWithHttpInfo
     *
     * List Call Logs
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\LogList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCallLogsWithHttpInfo($account_id, $call_id)
    {
        $request = $this->listCallLogsRequest($account_id, $call_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\LogList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\LogList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\LogList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\LogList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCallLogsAsync
     *
     * List Call Logs
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCallLogsAsync($account_id, $call_id)
    {
        return $this->listCallLogsAsyncWithHttpInfo($account_id, $call_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCallLogsAsyncWithHttpInfo
     *
     * List Call Logs
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCallLogsAsyncWithHttpInfo($account_id, $call_id)
    {
        $returnType = '\FreeClimb\PerCL\LogList';
        $request = $this->listCallLogsRequest($account_id, $call_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCallLogs'
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCallLogsRequest($account_id, $call_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listCallLogs'
            );
        }
        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling listCallLogs'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Calls/{callId}/Logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCallRecordings
     *
     * List Call Recordings
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     * @param  string $date_created Only show recordings created on the specified date, in the form *YYYY-MM-DD*. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\RecordingList
     */
    public function listCallRecordings($account_id, $call_id, $date_created = null)
    {
        list($response) = $this->listCallRecordingsWithHttpInfo($account_id, $call_id, $date_created);
        return $response;
    }

    /**
     * Operation listCallRecordingsWithHttpInfo
     *
     * List Call Recordings
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     * @param  string $date_created Only show recordings created on the specified date, in the form *YYYY-MM-DD*. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\RecordingList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCallRecordingsWithHttpInfo($account_id, $call_id, $date_created = null)
    {
        $request = $this->listCallRecordingsRequest($account_id, $call_id, $date_created);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\RecordingList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\RecordingList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\RecordingList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\RecordingList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCallRecordingsAsync
     *
     * List Call Recordings
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     * @param  string $date_created Only show recordings created on the specified date, in the form *YYYY-MM-DD*. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCallRecordingsAsync($account_id, $call_id, $date_created = null)
    {
        return $this->listCallRecordingsAsyncWithHttpInfo($account_id, $call_id, $date_created)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCallRecordingsAsyncWithHttpInfo
     *
     * List Call Recordings
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     * @param  string $date_created Only show recordings created on the specified date, in the form *YYYY-MM-DD*. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCallRecordingsAsyncWithHttpInfo($account_id, $call_id, $date_created = null)
    {
        $returnType = '\FreeClimb\PerCL\RecordingList';
        $request = $this->listCallRecordingsRequest($account_id, $call_id, $date_created);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCallRecordings'
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     * @param  string $date_created Only show recordings created on the specified date, in the form *YYYY-MM-DD*. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCallRecordingsRequest($account_id, $call_id, $date_created = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listCallRecordings'
            );
        }
        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling listCallRecordings'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Calls/{callId}/Recordings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date_created !== null) {
            $queryParams['dateCreated'] = ObjectSerializer::toQueryValue($date_created);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCalls
     *
     * List Calls
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $to Only show Calls to this phone number. (optional)
     * @param  string $from Only show Calls from this phone number. (optional)
     * @param  string $status Only show Calls currently in this status. May be &#x60;queued&#x60;, &#x60;ringing&#x60;, &#x60;inProgress&#x60;, &#x60;canceled&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;busy&#x60;, or &#x60;noAnswer&#x60;. (optional)
     * @param  string $start_time Only show Calls that started at or after this time, given as YYYY-MM-DD hh:mm:ss. (optional)
     * @param  string $end_time Only show Calls that ended at or before this time, given as YYYY-MM- DD hh:mm:ss. (optional)
     * @param  string $parent_call_id Only show Calls spawned by the call with this ID. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\CallList
     */
    public function listCalls($account_id, $to = null, $from = null, $status = null, $start_time = null, $end_time = null, $parent_call_id = null)
    {
        list($response) = $this->listCallsWithHttpInfo($account_id, $to, $from, $status, $start_time, $end_time, $parent_call_id);
        return $response;
    }

    /**
     * Operation listCallsWithHttpInfo
     *
     * List Calls
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $to Only show Calls to this phone number. (optional)
     * @param  string $from Only show Calls from this phone number. (optional)
     * @param  string $status Only show Calls currently in this status. May be &#x60;queued&#x60;, &#x60;ringing&#x60;, &#x60;inProgress&#x60;, &#x60;canceled&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;busy&#x60;, or &#x60;noAnswer&#x60;. (optional)
     * @param  string $start_time Only show Calls that started at or after this time, given as YYYY-MM-DD hh:mm:ss. (optional)
     * @param  string $end_time Only show Calls that ended at or before this time, given as YYYY-MM- DD hh:mm:ss. (optional)
     * @param  string $parent_call_id Only show Calls spawned by the call with this ID. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\CallList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCallsWithHttpInfo($account_id, $to = null, $from = null, $status = null, $start_time = null, $end_time = null, $parent_call_id = null)
    {
        $request = $this->listCallsRequest($account_id, $to, $from, $status, $start_time, $end_time, $parent_call_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\CallList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\CallList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\CallList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\CallList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCallsAsync
     *
     * List Calls
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $to Only show Calls to this phone number. (optional)
     * @param  string $from Only show Calls from this phone number. (optional)
     * @param  string $status Only show Calls currently in this status. May be &#x60;queued&#x60;, &#x60;ringing&#x60;, &#x60;inProgress&#x60;, &#x60;canceled&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;busy&#x60;, or &#x60;noAnswer&#x60;. (optional)
     * @param  string $start_time Only show Calls that started at or after this time, given as YYYY-MM-DD hh:mm:ss. (optional)
     * @param  string $end_time Only show Calls that ended at or before this time, given as YYYY-MM- DD hh:mm:ss. (optional)
     * @param  string $parent_call_id Only show Calls spawned by the call with this ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCallsAsync($account_id, $to = null, $from = null, $status = null, $start_time = null, $end_time = null, $parent_call_id = null)
    {
        return $this->listCallsAsyncWithHttpInfo($account_id, $to, $from, $status, $start_time, $end_time, $parent_call_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCallsAsyncWithHttpInfo
     *
     * List Calls
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $to Only show Calls to this phone number. (optional)
     * @param  string $from Only show Calls from this phone number. (optional)
     * @param  string $status Only show Calls currently in this status. May be &#x60;queued&#x60;, &#x60;ringing&#x60;, &#x60;inProgress&#x60;, &#x60;canceled&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;busy&#x60;, or &#x60;noAnswer&#x60;. (optional)
     * @param  string $start_time Only show Calls that started at or after this time, given as YYYY-MM-DD hh:mm:ss. (optional)
     * @param  string $end_time Only show Calls that ended at or before this time, given as YYYY-MM- DD hh:mm:ss. (optional)
     * @param  string $parent_call_id Only show Calls spawned by the call with this ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCallsAsyncWithHttpInfo($account_id, $to = null, $from = null, $status = null, $start_time = null, $end_time = null, $parent_call_id = null)
    {
        $returnType = '\FreeClimb\PerCL\CallList';
        $request = $this->listCallsRequest($account_id, $to, $from, $status, $start_time, $end_time, $parent_call_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCalls'
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $to Only show Calls to this phone number. (optional)
     * @param  string $from Only show Calls from this phone number. (optional)
     * @param  string $status Only show Calls currently in this status. May be &#x60;queued&#x60;, &#x60;ringing&#x60;, &#x60;inProgress&#x60;, &#x60;canceled&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;busy&#x60;, or &#x60;noAnswer&#x60;. (optional)
     * @param  string $start_time Only show Calls that started at or after this time, given as YYYY-MM-DD hh:mm:ss. (optional)
     * @param  string $end_time Only show Calls that ended at or before this time, given as YYYY-MM- DD hh:mm:ss. (optional)
     * @param  string $parent_call_id Only show Calls spawned by the call with this ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCallsRequest($account_id, $to = null, $from = null, $status = null, $start_time = null, $end_time = null, $parent_call_id = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listCalls'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Calls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = ObjectSerializer::toQueryValue($start_time);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = ObjectSerializer::toQueryValue($end_time);
        }
        // query params
        if ($parent_call_id !== null) {
            $queryParams['parentCallId'] = ObjectSerializer::toQueryValue($parent_call_id);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConferences
     *
     * List Conferences
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $status Only show conferences that currently have the specified status. Valid values: &#x60;empty&#x60;, &#x60;populated&#x60;, &#x60;inProgress&#x60;, or &#x60;terminated&#x60;. (optional)
     * @param  string $alias List Conferences whose alias exactly matches this string. (optional)
     * @param  string $date_created Only show Conferences that were created on the specified date, in the form *YYYY-MM-DD*. (optional)
     * @param  string $date_updated Only show Conferences that were last updated on the specified date, in the form *YYYY-MM-DD*. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\ConferenceList
     */
    public function listConferences($account_id, $status = null, $alias = null, $date_created = null, $date_updated = null)
    {
        list($response) = $this->listConferencesWithHttpInfo($account_id, $status, $alias, $date_created, $date_updated);
        return $response;
    }

    /**
     * Operation listConferencesWithHttpInfo
     *
     * List Conferences
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $status Only show conferences that currently have the specified status. Valid values: &#x60;empty&#x60;, &#x60;populated&#x60;, &#x60;inProgress&#x60;, or &#x60;terminated&#x60;. (optional)
     * @param  string $alias List Conferences whose alias exactly matches this string. (optional)
     * @param  string $date_created Only show Conferences that were created on the specified date, in the form *YYYY-MM-DD*. (optional)
     * @param  string $date_updated Only show Conferences that were last updated on the specified date, in the form *YYYY-MM-DD*. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\ConferenceList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConferencesWithHttpInfo($account_id, $status = null, $alias = null, $date_created = null, $date_updated = null)
    {
        $request = $this->listConferencesRequest($account_id, $status, $alias, $date_created, $date_updated);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\ConferenceList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\ConferenceList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\ConferenceList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\ConferenceList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConferencesAsync
     *
     * List Conferences
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $status Only show conferences that currently have the specified status. Valid values: &#x60;empty&#x60;, &#x60;populated&#x60;, &#x60;inProgress&#x60;, or &#x60;terminated&#x60;. (optional)
     * @param  string $alias List Conferences whose alias exactly matches this string. (optional)
     * @param  string $date_created Only show Conferences that were created on the specified date, in the form *YYYY-MM-DD*. (optional)
     * @param  string $date_updated Only show Conferences that were last updated on the specified date, in the form *YYYY-MM-DD*. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConferencesAsync($account_id, $status = null, $alias = null, $date_created = null, $date_updated = null)
    {
        return $this->listConferencesAsyncWithHttpInfo($account_id, $status, $alias, $date_created, $date_updated)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConferencesAsyncWithHttpInfo
     *
     * List Conferences
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $status Only show conferences that currently have the specified status. Valid values: &#x60;empty&#x60;, &#x60;populated&#x60;, &#x60;inProgress&#x60;, or &#x60;terminated&#x60;. (optional)
     * @param  string $alias List Conferences whose alias exactly matches this string. (optional)
     * @param  string $date_created Only show Conferences that were created on the specified date, in the form *YYYY-MM-DD*. (optional)
     * @param  string $date_updated Only show Conferences that were last updated on the specified date, in the form *YYYY-MM-DD*. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConferencesAsyncWithHttpInfo($account_id, $status = null, $alias = null, $date_created = null, $date_updated = null)
    {
        $returnType = '\FreeClimb\PerCL\ConferenceList';
        $request = $this->listConferencesRequest($account_id, $status, $alias, $date_created, $date_updated);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConferences'
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $status Only show conferences that currently have the specified status. Valid values: &#x60;empty&#x60;, &#x60;populated&#x60;, &#x60;inProgress&#x60;, or &#x60;terminated&#x60;. (optional)
     * @param  string $alias List Conferences whose alias exactly matches this string. (optional)
     * @param  string $date_created Only show Conferences that were created on the specified date, in the form *YYYY-MM-DD*. (optional)
     * @param  string $date_updated Only show Conferences that were last updated on the specified date, in the form *YYYY-MM-DD*. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConferencesRequest($account_id, $status = null, $alias = null, $date_created = null, $date_updated = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listConferences'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Conferences';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($alias !== null) {
            $queryParams['alias'] = ObjectSerializer::toQueryValue($alias);
        }
        // query params
        if ($date_created !== null) {
            $queryParams['dateCreated'] = ObjectSerializer::toQueryValue($date_created);
        }
        // query params
        if ($date_updated !== null) {
            $queryParams['dateUpdated'] = ObjectSerializer::toQueryValue($date_updated);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listIncomingNumbers
     *
     * List Incoming Numbers
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number Only show incoming phone number resources that match this PCRE-compatible regular expression. (optional)
     * @param  string $alias Only show incoming phone numbers with aliases that exactly match this value. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\IncomingNumberList
     */
    public function listIncomingNumbers($account_id, $phone_number = null, $alias = null)
    {
        list($response) = $this->listIncomingNumbersWithHttpInfo($account_id, $phone_number, $alias);
        return $response;
    }

    /**
     * Operation listIncomingNumbersWithHttpInfo
     *
     * List Incoming Numbers
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number Only show incoming phone number resources that match this PCRE-compatible regular expression. (optional)
     * @param  string $alias Only show incoming phone numbers with aliases that exactly match this value. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\IncomingNumberList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listIncomingNumbersWithHttpInfo($account_id, $phone_number = null, $alias = null)
    {
        $request = $this->listIncomingNumbersRequest($account_id, $phone_number, $alias);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\IncomingNumberList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\IncomingNumberList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\IncomingNumberList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\IncomingNumberList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listIncomingNumbersAsync
     *
     * List Incoming Numbers
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number Only show incoming phone number resources that match this PCRE-compatible regular expression. (optional)
     * @param  string $alias Only show incoming phone numbers with aliases that exactly match this value. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listIncomingNumbersAsync($account_id, $phone_number = null, $alias = null)
    {
        return $this->listIncomingNumbersAsyncWithHttpInfo($account_id, $phone_number, $alias)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listIncomingNumbersAsyncWithHttpInfo
     *
     * List Incoming Numbers
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number Only show incoming phone number resources that match this PCRE-compatible regular expression. (optional)
     * @param  string $alias Only show incoming phone numbers with aliases that exactly match this value. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listIncomingNumbersAsyncWithHttpInfo($account_id, $phone_number = null, $alias = null)
    {
        $returnType = '\FreeClimb\PerCL\IncomingNumberList';
        $request = $this->listIncomingNumbersRequest($account_id, $phone_number, $alias);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listIncomingNumbers'
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number Only show incoming phone number resources that match this PCRE-compatible regular expression. (optional)
     * @param  string $alias Only show incoming phone numbers with aliases that exactly match this value. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listIncomingNumbersRequest($account_id, $phone_number = null, $alias = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listIncomingNumbers'
            );
        }

        $resourcePath = '/Accounts/{accountId}/IncomingPhoneNumbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($phone_number !== null) {
            $queryParams['phoneNumber'] = ObjectSerializer::toQueryValue($phone_number);
        }
        // query params
        if ($alias !== null) {
            $queryParams['alias'] = ObjectSerializer::toQueryValue($alias);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMembers
     *
     * List Members
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\QueueMemberList
     */
    public function listMembers($account_id, $queue_id)
    {
        list($response) = $this->listMembersWithHttpInfo($account_id, $queue_id);
        return $response;
    }

    /**
     * Operation listMembersWithHttpInfo
     *
     * List Members
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\QueueMemberList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMembersWithHttpInfo($account_id, $queue_id)
    {
        $request = $this->listMembersRequest($account_id, $queue_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\QueueMemberList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\QueueMemberList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\QueueMemberList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\QueueMemberList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listMembersAsync
     *
     * List Members
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMembersAsync($account_id, $queue_id)
    {
        return $this->listMembersAsyncWithHttpInfo($account_id, $queue_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMembersAsyncWithHttpInfo
     *
     * List Members
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMembersAsyncWithHttpInfo($account_id, $queue_id)
    {
        $returnType = '\FreeClimb\PerCL\QueueMemberList';
        $request = $this->listMembersRequest($account_id, $queue_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMembers'
     *
     * @param  string $account_id ID of the account that created this Queue (required)
     * @param  string $queue_id String that uniquely identifies the Queue that the Member belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listMembersRequest($account_id, $queue_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listMembers'
            );
        }
        // verify the required parameter 'queue_id' is set
        if ($queue_id === null || (is_array($queue_id) && count($queue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_id when calling listMembers'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Queues/{queueId}/Members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($queue_id !== null) {
            $resourcePath = str_replace(
                '{' . 'queueId' . '}',
                ObjectSerializer::toPathValue($queue_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listParticipants
     *
     * List Participants
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  bool $talk Only show Participants with the talk privilege. (optional)
     * @param  bool $listen Only show Participants with the listen privilege. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\ConferenceParticipantList
     */
    public function listParticipants($account_id, $conference_id, $talk = null, $listen = null)
    {
        list($response) = $this->listParticipantsWithHttpInfo($account_id, $conference_id, $talk, $listen);
        return $response;
    }

    /**
     * Operation listParticipantsWithHttpInfo
     *
     * List Participants
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  bool $talk Only show Participants with the talk privilege. (optional)
     * @param  bool $listen Only show Participants with the listen privilege. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\ConferenceParticipantList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listParticipantsWithHttpInfo($account_id, $conference_id, $talk = null, $listen = null)
    {
        $request = $this->listParticipantsRequest($account_id, $conference_id, $talk, $listen);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\ConferenceParticipantList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\ConferenceParticipantList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\ConferenceParticipantList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\ConferenceParticipantList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listParticipantsAsync
     *
     * List Participants
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  bool $talk Only show Participants with the talk privilege. (optional)
     * @param  bool $listen Only show Participants with the listen privilege. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listParticipantsAsync($account_id, $conference_id, $talk = null, $listen = null)
    {
        return $this->listParticipantsAsyncWithHttpInfo($account_id, $conference_id, $talk, $listen)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listParticipantsAsyncWithHttpInfo
     *
     * List Participants
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  bool $talk Only show Participants with the talk privilege. (optional)
     * @param  bool $listen Only show Participants with the listen privilege. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listParticipantsAsyncWithHttpInfo($account_id, $conference_id, $talk = null, $listen = null)
    {
        $returnType = '\FreeClimb\PerCL\ConferenceParticipantList';
        $request = $this->listParticipantsRequest($account_id, $conference_id, $talk, $listen);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listParticipants'
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  bool $talk Only show Participants with the talk privilege. (optional)
     * @param  bool $listen Only show Participants with the listen privilege. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listParticipantsRequest($account_id, $conference_id, $talk = null, $listen = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listParticipants'
            );
        }
        // verify the required parameter 'conference_id' is set
        if ($conference_id === null || (is_array($conference_id) && count($conference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_id when calling listParticipants'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Conferences/{conferenceId}/Participants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($talk !== null) {
            $queryParams['talk'] = ObjectSerializer::toQueryValue($talk);
        }
        // query params
        if ($listen !== null) {
            $queryParams['listen'] = ObjectSerializer::toQueryValue($listen);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($conference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'conferenceId' . '}',
                ObjectSerializer::toPathValue($conference_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listRecordings
     *
     * List Recordings
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)
     * @param  string $conference_id Show only Recordings made during the conference with this ID. (optional)
     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\RecordingList
     */
    public function listRecordings($account_id, $call_id = null, $conference_id = null, $date_created = null)
    {
        list($response) = $this->listRecordingsWithHttpInfo($account_id, $call_id, $conference_id, $date_created);
        return $response;
    }

    /**
     * Operation listRecordingsWithHttpInfo
     *
     * List Recordings
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)
     * @param  string $conference_id Show only Recordings made during the conference with this ID. (optional)
     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\RecordingList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listRecordingsWithHttpInfo($account_id, $call_id = null, $conference_id = null, $date_created = null)
    {
        $request = $this->listRecordingsRequest($account_id, $call_id, $conference_id, $date_created);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\RecordingList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\RecordingList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\RecordingList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\RecordingList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listRecordingsAsync
     *
     * List Recordings
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)
     * @param  string $conference_id Show only Recordings made during the conference with this ID. (optional)
     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRecordingsAsync($account_id, $call_id = null, $conference_id = null, $date_created = null)
    {
        return $this->listRecordingsAsyncWithHttpInfo($account_id, $call_id, $conference_id, $date_created)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listRecordingsAsyncWithHttpInfo
     *
     * List Recordings
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)
     * @param  string $conference_id Show only Recordings made during the conference with this ID. (optional)
     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRecordingsAsyncWithHttpInfo($account_id, $call_id = null, $conference_id = null, $date_created = null)
    {
        $returnType = '\FreeClimb\PerCL\RecordingList';
        $request = $this->listRecordingsRequest($account_id, $call_id, $conference_id, $date_created);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listRecordings'
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $call_id Show only Recordings made during the Call with this ID. (optional)
     * @param  string $conference_id Show only Recordings made during the conference with this ID. (optional)
     * @param  string $date_created Only show Recordings created on this date, formatted as *YYYY-MM-DD*. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listRecordingsRequest($account_id, $call_id = null, $conference_id = null, $date_created = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listRecordings'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Recordings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($call_id !== null) {
            $queryParams['callId'] = ObjectSerializer::toQueryValue($call_id);
        }
        // query params
        if ($conference_id !== null) {
            $queryParams['conferenceId'] = ObjectSerializer::toQueryValue($conference_id);
        }
        // query params
        if ($date_created !== null) {
            $queryParams['dateCreated'] = ObjectSerializer::toQueryValue($date_created);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listSmsMessages
     *
     * List SMS Messages
     *
     * @param  string $account_id2 ID of the account that sent this message. (required)
     * @param  string $to Only show Messages to this phone number. (optional)
     * @param  string $from Only show Messages from this phone number. (optional)
     * @param  string $begin_time Only show Messages sent at or after this time (GMT), given as *YYYY-MM-DD hh:mm:ss*. (optional)
     * @param  string $end_time Only show messages sent at or before this time (GMT), given as *YYYY-MM-DD hh:mm*.. (optional)
     * @param  string $direction Either &#x60;inbound&#x60; or &#x60;outbound&#x60;. Only show Messages that were either *sent from* or *received by* FreeClimb. (optional)
     * @param  string $account_id String that uniquely identifies this account resource. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\MessagesList
     */
    public function listSmsMessages($account_id2, $to = null, $from = null, $begin_time = null, $end_time = null, $direction = null, $account_id = null)
    {
        list($response) = $this->listSmsMessagesWithHttpInfo($account_id2, $to, $from, $begin_time, $end_time, $direction, $account_id);
        return $response;
    }

    /**
     * Operation listSmsMessagesWithHttpInfo
     *
     * List SMS Messages
     *
     * @param  string $account_id2 ID of the account that sent this message. (required)
     * @param  string $to Only show Messages to this phone number. (optional)
     * @param  string $from Only show Messages from this phone number. (optional)
     * @param  string $begin_time Only show Messages sent at or after this time (GMT), given as *YYYY-MM-DD hh:mm:ss*. (optional)
     * @param  string $end_time Only show messages sent at or before this time (GMT), given as *YYYY-MM-DD hh:mm*.. (optional)
     * @param  string $direction Either &#x60;inbound&#x60; or &#x60;outbound&#x60;. Only show Messages that were either *sent from* or *received by* FreeClimb. (optional)
     * @param  string $account_id String that uniquely identifies this account resource. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\MessagesList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listSmsMessagesWithHttpInfo($account_id2, $to = null, $from = null, $begin_time = null, $end_time = null, $direction = null, $account_id = null)
    {
        $request = $this->listSmsMessagesRequest($account_id2, $to, $from, $begin_time, $end_time, $direction, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\MessagesList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\MessagesList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\MessagesList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\MessagesList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listSmsMessagesAsync
     *
     * List SMS Messages
     *
     * @param  string $account_id2 ID of the account that sent this message. (required)
     * @param  string $to Only show Messages to this phone number. (optional)
     * @param  string $from Only show Messages from this phone number. (optional)
     * @param  string $begin_time Only show Messages sent at or after this time (GMT), given as *YYYY-MM-DD hh:mm:ss*. (optional)
     * @param  string $end_time Only show messages sent at or before this time (GMT), given as *YYYY-MM-DD hh:mm*.. (optional)
     * @param  string $direction Either &#x60;inbound&#x60; or &#x60;outbound&#x60;. Only show Messages that were either *sent from* or *received by* FreeClimb. (optional)
     * @param  string $account_id String that uniquely identifies this account resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSmsMessagesAsync($account_id2, $to = null, $from = null, $begin_time = null, $end_time = null, $direction = null, $account_id = null)
    {
        return $this->listSmsMessagesAsyncWithHttpInfo($account_id2, $to, $from, $begin_time, $end_time, $direction, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listSmsMessagesAsyncWithHttpInfo
     *
     * List SMS Messages
     *
     * @param  string $account_id2 ID of the account that sent this message. (required)
     * @param  string $to Only show Messages to this phone number. (optional)
     * @param  string $from Only show Messages from this phone number. (optional)
     * @param  string $begin_time Only show Messages sent at or after this time (GMT), given as *YYYY-MM-DD hh:mm:ss*. (optional)
     * @param  string $end_time Only show messages sent at or before this time (GMT), given as *YYYY-MM-DD hh:mm*.. (optional)
     * @param  string $direction Either &#x60;inbound&#x60; or &#x60;outbound&#x60;. Only show Messages that were either *sent from* or *received by* FreeClimb. (optional)
     * @param  string $account_id String that uniquely identifies this account resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSmsMessagesAsyncWithHttpInfo($account_id2, $to = null, $from = null, $begin_time = null, $end_time = null, $direction = null, $account_id = null)
    {
        $returnType = '\FreeClimb\PerCL\MessagesList';
        $request = $this->listSmsMessagesRequest($account_id2, $to, $from, $begin_time, $end_time, $direction, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listSmsMessages'
     *
     * @param  string $account_id2 ID of the account that sent this message. (required)
     * @param  string $to Only show Messages to this phone number. (optional)
     * @param  string $from Only show Messages from this phone number. (optional)
     * @param  string $begin_time Only show Messages sent at or after this time (GMT), given as *YYYY-MM-DD hh:mm:ss*. (optional)
     * @param  string $end_time Only show messages sent at or before this time (GMT), given as *YYYY-MM-DD hh:mm*.. (optional)
     * @param  string $direction Either &#x60;inbound&#x60; or &#x60;outbound&#x60;. Only show Messages that were either *sent from* or *received by* FreeClimb. (optional)
     * @param  string $account_id String that uniquely identifies this account resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listSmsMessagesRequest($account_id2, $to = null, $from = null, $begin_time = null, $end_time = null, $direction = null, $account_id = null)
    {
        // verify the required parameter 'account_id2' is set
        if ($account_id2 === null || (is_array($account_id2) && count($account_id2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id2 when calling listSmsMessages'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($begin_time !== null) {
            $queryParams['beginTime'] = ObjectSerializer::toQueryValue($begin_time);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = ObjectSerializer::toQueryValue($end_time);
        }
        // query params
        if ($direction !== null) {
            $queryParams['direction'] = ObjectSerializer::toQueryValue($direction);
        }
        // query params
        if ($account_id !== null) {
            $queryParams['accountID'] = ObjectSerializer::toQueryValue($account_id);
        }

        // path params
        if ($account_id2 !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id2),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation makeACall
     *
     * Make a Call
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  \FreeClimb\PerCL\MakeCallRequest $make_call_request Call details for making a call (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\CallResult
     */
    public function makeACall($account_id, $make_call_request = null)
    {
        list($response) = $this->makeACallWithHttpInfo($account_id, $make_call_request);
        return $response;
    }

    /**
     * Operation makeACallWithHttpInfo
     *
     * Make a Call
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  \FreeClimb\PerCL\MakeCallRequest $make_call_request Call details for making a call (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\CallResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function makeACallWithHttpInfo($account_id, $make_call_request = null)
    {
        $request = $this->makeACallRequest($account_id, $make_call_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\CallResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\CallResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\CallResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\CallResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation makeACallAsync
     *
     * Make a Call
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  \FreeClimb\PerCL\MakeCallRequest $make_call_request Call details for making a call (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function makeACallAsync($account_id, $make_call_request = null)
    {
        return $this->makeACallAsyncWithHttpInfo($account_id, $make_call_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation makeACallAsyncWithHttpInfo
     *
     * Make a Call
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  \FreeClimb\PerCL\MakeCallRequest $make_call_request Call details for making a call (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function makeACallAsyncWithHttpInfo($account_id, $make_call_request = null)
    {
        $returnType = '\FreeClimb\PerCL\CallResult';
        $request = $this->makeACallRequest($account_id, $make_call_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'makeACall'
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  \FreeClimb\PerCL\MakeCallRequest $make_call_request Call details for making a call (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function makeACallRequest($account_id, $make_call_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling makeACall'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Calls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($make_call_request)) {
            $_tempBody = $make_call_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeAParticipant
     *
     * Remove a Participant
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function removeAParticipant($account_id, $conference_id, $call_id)
    {
        $this->removeAParticipantWithHttpInfo($account_id, $conference_id, $call_id);
    }

    /**
     * Operation removeAParticipantWithHttpInfo
     *
     * Remove a Participant
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeAParticipantWithHttpInfo($account_id, $conference_id, $call_id)
    {
        $request = $this->removeAParticipantRequest($account_id, $conference_id, $call_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation removeAParticipantAsync
     *
     * Remove a Participant
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAParticipantAsync($account_id, $conference_id, $call_id)
    {
        return $this->removeAParticipantAsyncWithHttpInfo($account_id, $conference_id, $call_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeAParticipantAsyncWithHttpInfo
     *
     * Remove a Participant
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAParticipantAsyncWithHttpInfo($account_id, $conference_id, $call_id)
    {
        $returnType = '';
        $request = $this->removeAParticipantRequest($account_id, $conference_id, $call_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeAParticipant'
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function removeAParticipantRequest($account_id, $conference_id, $call_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling removeAParticipant'
            );
        }
        // verify the required parameter 'conference_id' is set
        if ($conference_id === null || (is_array($conference_id) && count($conference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_id when calling removeAParticipant'
            );
        }
        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling removeAParticipant'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Conferences/{conferenceId}/Participants/{callId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($conference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'conferenceId' . '}',
                ObjectSerializer::toPathValue($conference_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendAnSmsMessage
     *
     * Send an SMS Message
     *
     * @param  string $account_id ID of the account that sent this message. (required)
     * @param  \FreeClimb\PerCL\MessageRequest $message_request Details to create a message (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\MessageResult
     */
    public function sendAnSmsMessage($account_id, $message_request = null)
    {
        list($response) = $this->sendAnSmsMessageWithHttpInfo($account_id, $message_request);
        return $response;
    }

    /**
     * Operation sendAnSmsMessageWithHttpInfo
     *
     * Send an SMS Message
     *
     * @param  string $account_id ID of the account that sent this message. (required)
     * @param  \FreeClimb\PerCL\MessageRequest $message_request Details to create a message (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\MessageResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendAnSmsMessageWithHttpInfo($account_id, $message_request = null)
    {
        $request = $this->sendAnSmsMessageRequest($account_id, $message_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 202:
                    if ('\FreeClimb\PerCL\MessageResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\MessageResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\MessageResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\MessageResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendAnSmsMessageAsync
     *
     * Send an SMS Message
     *
     * @param  string $account_id ID of the account that sent this message. (required)
     * @param  \FreeClimb\PerCL\MessageRequest $message_request Details to create a message (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendAnSmsMessageAsync($account_id, $message_request = null)
    {
        return $this->sendAnSmsMessageAsyncWithHttpInfo($account_id, $message_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendAnSmsMessageAsyncWithHttpInfo
     *
     * Send an SMS Message
     *
     * @param  string $account_id ID of the account that sent this message. (required)
     * @param  \FreeClimb\PerCL\MessageRequest $message_request Details to create a message (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendAnSmsMessageAsyncWithHttpInfo($account_id, $message_request = null)
    {
        $returnType = '\FreeClimb\PerCL\MessageResult';
        $request = $this->sendAnSmsMessageRequest($account_id, $message_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendAnSmsMessage'
     *
     * @param  string $account_id ID of the account that sent this message. (required)
     * @param  \FreeClimb\PerCL\MessageRequest $message_request Details to create a message (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sendAnSmsMessageRequest($account_id, $message_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling sendAnSmsMessage'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($message_request)) {
            $_tempBody = $message_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation streamARecordingFile
     *
     * Stream a Recording File
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function streamARecordingFile($account_id, $recording_id)
    {
        list($response) = $this->streamARecordingFileWithHttpInfo($account_id, $recording_id);
        return $response;
    }

    /**
     * Operation streamARecordingFileWithHttpInfo
     *
     * Stream a Recording File
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamARecordingFileWithHttpInfo($account_id, $recording_id)
    {
        $request = $this->streamARecordingFileRequest($account_id, $recording_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation streamARecordingFileAsync
     *
     * Stream a Recording File
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function streamARecordingFileAsync($account_id, $recording_id)
    {
        return $this->streamARecordingFileAsyncWithHttpInfo($account_id, $recording_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation streamARecordingFileAsyncWithHttpInfo
     *
     * Stream a Recording File
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function streamARecordingFileAsyncWithHttpInfo($account_id, $recording_id)
    {
        $returnType = '\SplFileObject';
        $request = $this->streamARecordingFileRequest($account_id, $recording_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'streamARecordingFile'
     *
     * @param  string $account_id ID of the account that created this recording. (required)
     * @param  string $recording_id String that uniquely identifies this recording resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function streamARecordingFileRequest($account_id, $recording_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling streamARecordingFile'
            );
        }
        // verify the required parameter 'recording_id' is set
        if ($recording_id === null || (is_array($recording_id) && count($recording_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_id when calling streamARecordingFile'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Recordings/{recordingId}/Stream';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($recording_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recordingId' . '}',
                ObjectSerializer::toPathValue($recording_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['audio/x-wav']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['audio/x-wav'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAConference
     *
     * Update a Conference
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $conference_id String that uniquely identifies this conference resource. (required)
     * @param  \FreeClimb\PerCL\UpdateConferenceRequest $update_conference_request Conference Details to update (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\ConferenceResult
     */
    public function updateAConference($account_id, $conference_id, $update_conference_request = null)
    {
        list($response) = $this->updateAConferenceWithHttpInfo($account_id, $conference_id, $update_conference_request);
        return $response;
    }

    /**
     * Operation updateAConferenceWithHttpInfo
     *
     * Update a Conference
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $conference_id String that uniquely identifies this conference resource. (required)
     * @param  \FreeClimb\PerCL\UpdateConferenceRequest $update_conference_request Conference Details to update (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\ConferenceResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAConferenceWithHttpInfo($account_id, $conference_id, $update_conference_request = null)
    {
        $request = $this->updateAConferenceRequest($account_id, $conference_id, $update_conference_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\ConferenceResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\ConferenceResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\ConferenceResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\ConferenceResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAConferenceAsync
     *
     * Update a Conference
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $conference_id String that uniquely identifies this conference resource. (required)
     * @param  \FreeClimb\PerCL\UpdateConferenceRequest $update_conference_request Conference Details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAConferenceAsync($account_id, $conference_id, $update_conference_request = null)
    {
        return $this->updateAConferenceAsyncWithHttpInfo($account_id, $conference_id, $update_conference_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAConferenceAsyncWithHttpInfo
     *
     * Update a Conference
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $conference_id String that uniquely identifies this conference resource. (required)
     * @param  \FreeClimb\PerCL\UpdateConferenceRequest $update_conference_request Conference Details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAConferenceAsyncWithHttpInfo($account_id, $conference_id, $update_conference_request = null)
    {
        $returnType = '\FreeClimb\PerCL\ConferenceResult';
        $request = $this->updateAConferenceRequest($account_id, $conference_id, $update_conference_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAConference'
     *
     * @param  string $account_id ID of the account that created this conference. (required)
     * @param  string $conference_id String that uniquely identifies this conference resource. (required)
     * @param  \FreeClimb\PerCL\UpdateConferenceRequest $update_conference_request Conference Details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateAConferenceRequest($account_id, $conference_id, $update_conference_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateAConference'
            );
        }
        // verify the required parameter 'conference_id' is set
        if ($conference_id === null || (is_array($conference_id) && count($conference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_id when calling updateAConference'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Conferences/{conferenceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($conference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'conferenceId' . '}',
                ObjectSerializer::toPathValue($conference_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_conference_request)) {
            $_tempBody = $update_conference_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateALiveCall
     *
     * Update a Live Call
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     * @param  \FreeClimb\PerCL\UpdateCallRequest $update_call_request Call details to update (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateALiveCall($account_id, $call_id, $update_call_request = null)
    {
        $this->updateALiveCallWithHttpInfo($account_id, $call_id, $update_call_request);
    }

    /**
     * Operation updateALiveCallWithHttpInfo
     *
     * Update a Live Call
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     * @param  \FreeClimb\PerCL\UpdateCallRequest $update_call_request Call details to update (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateALiveCallWithHttpInfo($account_id, $call_id, $update_call_request = null)
    {
        $request = $this->updateALiveCallRequest($account_id, $call_id, $update_call_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateALiveCallAsync
     *
     * Update a Live Call
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     * @param  \FreeClimb\PerCL\UpdateCallRequest $update_call_request Call details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateALiveCallAsync($account_id, $call_id, $update_call_request = null)
    {
        return $this->updateALiveCallAsyncWithHttpInfo($account_id, $call_id, $update_call_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateALiveCallAsyncWithHttpInfo
     *
     * Update a Live Call
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     * @param  \FreeClimb\PerCL\UpdateCallRequest $update_call_request Call details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateALiveCallAsyncWithHttpInfo($account_id, $call_id, $update_call_request = null)
    {
        $returnType = '';
        $request = $this->updateALiveCallRequest($account_id, $call_id, $update_call_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateALiveCall'
     *
     * @param  string $account_id ID of the account that created this call. (required)
     * @param  string $call_id String that uniquely identifies this call resource. (required)
     * @param  \FreeClimb\PerCL\UpdateCallRequest $update_call_request Call details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateALiveCallRequest($account_id, $call_id, $update_call_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateALiveCall'
            );
        }
        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling updateALiveCall'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Calls/{callId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_call_request)) {
            $_tempBody = $update_call_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAParticipant
     *
     * Update a Participant
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     * @param  \FreeClimb\PerCL\UpdateConferenceParticipantRequest $update_conference_participant_request Conference participant details to update (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\ConferenceParticipantResult
     */
    public function updateAParticipant($account_id, $conference_id, $call_id, $update_conference_participant_request = null)
    {
        list($response) = $this->updateAParticipantWithHttpInfo($account_id, $conference_id, $call_id, $update_conference_participant_request);
        return $response;
    }

    /**
     * Operation updateAParticipantWithHttpInfo
     *
     * Update a Participant
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     * @param  \FreeClimb\PerCL\UpdateConferenceParticipantRequest $update_conference_participant_request Conference participant details to update (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\ConferenceParticipantResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAParticipantWithHttpInfo($account_id, $conference_id, $call_id, $update_conference_participant_request = null)
    {
        $request = $this->updateAParticipantRequest($account_id, $conference_id, $call_id, $update_conference_participant_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\ConferenceParticipantResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\ConferenceParticipantResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\ConferenceParticipantResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\ConferenceParticipantResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAParticipantAsync
     *
     * Update a Participant
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     * @param  \FreeClimb\PerCL\UpdateConferenceParticipantRequest $update_conference_participant_request Conference participant details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAParticipantAsync($account_id, $conference_id, $call_id, $update_conference_participant_request = null)
    {
        return $this->updateAParticipantAsyncWithHttpInfo($account_id, $conference_id, $call_id, $update_conference_participant_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAParticipantAsyncWithHttpInfo
     *
     * Update a Participant
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     * @param  \FreeClimb\PerCL\UpdateConferenceParticipantRequest $update_conference_participant_request Conference participant details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAParticipantAsyncWithHttpInfo($account_id, $conference_id, $call_id, $update_conference_participant_request = null)
    {
        $returnType = '\FreeClimb\PerCL\ConferenceParticipantResult';
        $request = $this->updateAParticipantRequest($account_id, $conference_id, $call_id, $update_conference_participant_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAParticipant'
     *
     * @param  string $account_id ID of the account that created this participant. (required)
     * @param  string $conference_id ID of the conference this participant is in. (required)
     * @param  string $call_id ID of the Call associated with this participant. (required)
     * @param  \FreeClimb\PerCL\UpdateConferenceParticipantRequest $update_conference_participant_request Conference participant details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateAParticipantRequest($account_id, $conference_id, $call_id, $update_conference_participant_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateAParticipant'
            );
        }
        // verify the required parameter 'conference_id' is set
        if ($conference_id === null || (is_array($conference_id) && count($conference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conference_id when calling updateAParticipant'
            );
        }
        // verify the required parameter 'call_id' is set
        if ($call_id === null || (is_array($call_id) && count($call_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $call_id when calling updateAParticipant'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Conferences/{conferenceId}/Participants/{callId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($conference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'conferenceId' . '}',
                ObjectSerializer::toPathValue($conference_id),
                $resourcePath
            );
        }
        // path params
        if ($call_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callId' . '}',
                ObjectSerializer::toPathValue($call_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_conference_participant_request)) {
            $_tempBody = $update_conference_participant_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAQueue
     *
     * Update a Queue
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id A string that uniquely identifies this Queue resource. (required)
     * @param  \FreeClimb\PerCL\QueueRequest $queue_request Queue Details to update (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\QueueResult
     */
    public function updateAQueue($account_id, $queue_id, $queue_request = null)
    {
        list($response) = $this->updateAQueueWithHttpInfo($account_id, $queue_id, $queue_request);
        return $response;
    }

    /**
     * Operation updateAQueueWithHttpInfo
     *
     * Update a Queue
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id A string that uniquely identifies this Queue resource. (required)
     * @param  \FreeClimb\PerCL\QueueRequest $queue_request Queue Details to update (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\QueueResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAQueueWithHttpInfo($account_id, $queue_id, $queue_request = null)
    {
        $request = $this->updateAQueueRequest($account_id, $queue_id, $queue_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\QueueResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\QueueResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\QueueResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\QueueResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAQueueAsync
     *
     * Update a Queue
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id A string that uniquely identifies this Queue resource. (required)
     * @param  \FreeClimb\PerCL\QueueRequest $queue_request Queue Details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAQueueAsync($account_id, $queue_id, $queue_request = null)
    {
        return $this->updateAQueueAsyncWithHttpInfo($account_id, $queue_id, $queue_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAQueueAsyncWithHttpInfo
     *
     * Update a Queue
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id A string that uniquely identifies this Queue resource. (required)
     * @param  \FreeClimb\PerCL\QueueRequest $queue_request Queue Details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAQueueAsyncWithHttpInfo($account_id, $queue_id, $queue_request = null)
    {
        $returnType = '\FreeClimb\PerCL\QueueResult';
        $request = $this->updateAQueueRequest($account_id, $queue_id, $queue_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAQueue'
     *
     * @param  string $account_id ID of the account that created this queue. (required)
     * @param  string $queue_id A string that uniquely identifies this Queue resource. (required)
     * @param  \FreeClimb\PerCL\QueueRequest $queue_request Queue Details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateAQueueRequest($account_id, $queue_id, $queue_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateAQueue'
            );
        }
        // verify the required parameter 'queue_id' is set
        if ($queue_id === null || (is_array($queue_id) && count($queue_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_id when calling updateAQueue'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Queues/{queueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($queue_id !== null) {
            $resourcePath = str_replace(
                '{' . 'queueId' . '}',
                ObjectSerializer::toPathValue($queue_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($queue_request)) {
            $_tempBody = $queue_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAnAccount
     *
     * Manage an account
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     * @param  \FreeClimb\PerCL\AccountRequest $account_request Account details to update (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateAnAccount($account_id, $account_request = null)
    {
        $this->updateAnAccountWithHttpInfo($account_id, $account_request);
    }

    /**
     * Operation updateAnAccountWithHttpInfo
     *
     * Manage an account
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     * @param  \FreeClimb\PerCL\AccountRequest $account_request Account details to update (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAnAccountWithHttpInfo($account_id, $account_request = null)
    {
        $request = $this->updateAnAccountRequest($account_id, $account_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateAnAccountAsync
     *
     * Manage an account
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     * @param  \FreeClimb\PerCL\AccountRequest $account_request Account details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnAccountAsync($account_id, $account_request = null)
    {
        return $this->updateAnAccountAsyncWithHttpInfo($account_id, $account_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAnAccountAsyncWithHttpInfo
     *
     * Manage an account
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     * @param  \FreeClimb\PerCL\AccountRequest $account_request Account details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnAccountAsyncWithHttpInfo($account_id, $account_request = null)
    {
        $returnType = '';
        $request = $this->updateAnAccountRequest($account_id, $account_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAnAccount'
     *
     * @param  string $account_id String that uniquely identifies this account resource. (required)
     * @param  \FreeClimb\PerCL\AccountRequest $account_request Account details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateAnAccountRequest($account_id, $account_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateAnAccount'
            );
        }

        $resourcePath = '/Accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($account_request)) {
            $_tempBody = $account_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAnApplication
     *
     * Update an application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id A string that uniquely identifies this application resource. (required)
     * @param  \FreeClimb\PerCL\ApplicationRequest $application_request Application details to update. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\ApplicationResult
     */
    public function updateAnApplication($account_id, $application_id, $application_request = null)
    {
        list($response) = $this->updateAnApplicationWithHttpInfo($account_id, $application_id, $application_request);
        return $response;
    }

    /**
     * Operation updateAnApplicationWithHttpInfo
     *
     * Update an application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id A string that uniquely identifies this application resource. (required)
     * @param  \FreeClimb\PerCL\ApplicationRequest $application_request Application details to update. (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\ApplicationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAnApplicationWithHttpInfo($account_id, $application_id, $application_request = null)
    {
        $request = $this->updateAnApplicationRequest($account_id, $application_id, $application_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\ApplicationResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\ApplicationResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\ApplicationResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\ApplicationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAnApplicationAsync
     *
     * Update an application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id A string that uniquely identifies this application resource. (required)
     * @param  \FreeClimb\PerCL\ApplicationRequest $application_request Application details to update. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnApplicationAsync($account_id, $application_id, $application_request = null)
    {
        return $this->updateAnApplicationAsyncWithHttpInfo($account_id, $application_id, $application_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAnApplicationAsyncWithHttpInfo
     *
     * Update an application
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id A string that uniquely identifies this application resource. (required)
     * @param  \FreeClimb\PerCL\ApplicationRequest $application_request Application details to update. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnApplicationAsyncWithHttpInfo($account_id, $application_id, $application_request = null)
    {
        $returnType = '\FreeClimb\PerCL\ApplicationResult';
        $request = $this->updateAnApplicationRequest($account_id, $application_id, $application_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAnApplication'
     *
     * @param  string $account_id ID of the account that created this application. (required)
     * @param  string $application_id A string that uniquely identifies this application resource. (required)
     * @param  \FreeClimb\PerCL\ApplicationRequest $application_request Application details to update. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateAnApplicationRequest($account_id, $application_id, $application_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateAnApplication'
            );
        }
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling updateAnApplication'
            );
        }

        $resourcePath = '/Accounts/{accountId}/Applications/{applicationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($application_request)) {
            $_tempBody = $application_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAnIncomingNumber
     *
     * Update an Incoming Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     * @param  \FreeClimb\PerCL\IncomingNumberRequest $incoming_number_request Incoming Number details to update (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FreeClimb\PerCL\IncomingNumberResult
     */
    public function updateAnIncomingNumber($account_id, $phone_number_id, $incoming_number_request = null)
    {
        list($response) = $this->updateAnIncomingNumberWithHttpInfo($account_id, $phone_number_id, $incoming_number_request);
        return $response;
    }

    /**
     * Operation updateAnIncomingNumberWithHttpInfo
     *
     * Update an Incoming Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     * @param  \FreeClimb\PerCL\IncomingNumberRequest $incoming_number_request Incoming Number details to update (optional)
     *
     * @throws \FreeClimb\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FreeClimb\PerCL\IncomingNumberResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAnIncomingNumberWithHttpInfo($account_id, $phone_number_id, $incoming_number_request = null)
    {
        $request = $this->updateAnIncomingNumberRequest($account_id, $phone_number_id, $incoming_number_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\FreeClimb\PerCL\IncomingNumberResult' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\FreeClimb\PerCL\IncomingNumberResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\FreeClimb\PerCL\IncomingNumberResult';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FreeClimb\PerCL\IncomingNumberResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAnIncomingNumberAsync
     *
     * Update an Incoming Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     * @param  \FreeClimb\PerCL\IncomingNumberRequest $incoming_number_request Incoming Number details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnIncomingNumberAsync($account_id, $phone_number_id, $incoming_number_request = null)
    {
        return $this->updateAnIncomingNumberAsyncWithHttpInfo($account_id, $phone_number_id, $incoming_number_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAnIncomingNumberAsyncWithHttpInfo
     *
     * Update an Incoming Number
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     * @param  \FreeClimb\PerCL\IncomingNumberRequest $incoming_number_request Incoming Number details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnIncomingNumberAsyncWithHttpInfo($account_id, $phone_number_id, $incoming_number_request = null)
    {
        $returnType = '\FreeClimb\PerCL\IncomingNumberResult';
        $request = $this->updateAnIncomingNumberRequest($account_id, $phone_number_id, $incoming_number_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAnIncomingNumber'
     *
     * @param  string $account_id ID of the account that owns this phone number. (required)
     * @param  string $phone_number_id String that uniquely identifies this phone number resource. (required)
     * @param  \FreeClimb\PerCL\IncomingNumberRequest $incoming_number_request Incoming Number details to update (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateAnIncomingNumberRequest($account_id, $phone_number_id, $incoming_number_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateAnIncomingNumber'
            );
        }
        // verify the required parameter 'phone_number_id' is set
        if ($phone_number_id === null || (is_array($phone_number_id) && count($phone_number_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phone_number_id when calling updateAnIncomingNumber'
            );
        }

        $resourcePath = '/Accounts/{accountId}/IncomingPhoneNumbers/{phoneNumberId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($phone_number_id !== null) {
            $resourcePath = str_replace(
                '{' . 'phoneNumberId' . '}',
                ObjectSerializer::toPathValue($phone_number_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($incoming_number_request)) {
            $_tempBody = $incoming_number_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
